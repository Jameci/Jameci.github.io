<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="本文是网课 https://www.bilibili.com/video/BV164411b7dx?p=2 的随堂笔记，仅供本人学习使用  前言机器学习的一些定义 Field of study that gives computers the ability to learn without being explicitly programmed.  —-Arthur Samuel  我的翻译：">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习入门课程笔记">
<meta property="og:url" content="http://yoursite.com/2023/01/15/机器学习入门课程笔记/index.html">
<meta property="og:site_name" content="Jameci&#39;s Blog">
<meta property="og:description" content="本文是网课 https://www.bilibili.com/video/BV164411b7dx?p=2 的随堂笔记，仅供本人学习使用  前言机器学习的一些定义 Field of study that gives computers the ability to learn without being explicitly programmed.  —-Arthur Samuel  我的翻译：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/0.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/1.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/2.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/3.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/4.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/5.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/6.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/7.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/8.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/9.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/10.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/11.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/12.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/0.jpg">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/13.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/14.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/15.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/16.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/17.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/18.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/19.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/20.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/21.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/22.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/23.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/24.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/25.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/26.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/27.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/28.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/29.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/30.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/31.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/32.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/33.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/34.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/35.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/36.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/37.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/38.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/39.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/40.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/41.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/42.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/43.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/44.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/45.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/46.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/47.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/48.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/49.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/53.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/50.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/51.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/54.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/55.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/56.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/57.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/58.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/59.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/60.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/61.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/62.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/63.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/64.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/65.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/66.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/67.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/68.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/69.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/70.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/71.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/72.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/73.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/74.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/75.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/76.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/77.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/78.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/79.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/80.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/81.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/82.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/83.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/84.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/85.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/86.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/87.png">
<meta property="og:image" content="http://yoursite.com/images/机器学习入门课程笔记/88.png">
<meta property="og:updated_time" content="2023-01-17T09:49:55.715Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机器学习入门课程笔记">
<meta name="twitter:description" content="本文是网课 https://www.bilibili.com/video/BV164411b7dx?p=2 的随堂笔记，仅供本人学习使用  前言机器学习的一些定义 Field of study that gives computers the ability to learn without being explicitly programmed.  —-Arthur Samuel  我的翻译：">
<meta name="twitter:image" content="http://yoursite.com/images/机器学习入门课程笔记/0.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2023/01/15/机器学习入门课程笔记/">





  <title>机器学习入门课程笔记 | Jameci's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jameci's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">天下雷行，物与无妄。先王以茂对时，育万物。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/01/15/机器学习入门课程笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jameci">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jameci's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">机器学习入门课程笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-01-15T18:06:52+08:00">
                2023-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文是网课 <a href="https://www.bilibili.com/video/BV164411b7dx?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV164411b7dx?p=2</a> 的随堂笔记，仅供本人学习使用</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="机器学习的一些定义"><a href="#机器学习的一些定义" class="headerlink" title="机器学习的一些定义"></a>机器学习的一些定义</h2><blockquote>
<p>Field of study that gives computers the ability to learn without being explicitly programmed.</p>
</blockquote>
<p align="right">—-Arthur Samuel</p>

<p>我的翻译：<strong>给予计算机不需要显式编程来进行学习的能力</strong></p>
<p>这里的显示编程是什么意思呢，比如小花编写了一个五子棋程序，他直接在程序里面写好遇到某种局面该怎么分析，或者直接写好该怎么走（比如遇到我方四子连线，立刻下第五个子），这叫所谓的显式编程</p>
<p>如果小花没有在程序里面写该怎么走，而是交给机器去自行训练，把训练的结果记录下来作为以后遇到这种局面的参考。下次遇到这个局面，计算机会根据自己的记录结果选择赢面最大的走法。这种便是上面定义里提到的不使用显示编程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explicitly: 显式地，明确地；其反义词是implicitly: 隐式地，暗中地</span><br><span class="line"></span><br><span class="line">常见使用：explicit type-casting：显示类型转换，implicit type-casting：隐式类型转换</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p>
</blockquote>
<p align="right">—-Tom Mitchell</p>

<p>我的翻译：<strong>一个通过经验E在任务T上进行学习，并用度量手段P去度量的计算机程序，如果它能够在经验E的作用下，通过P度量的在T上的结果有所提升，那么它就是一个好的机器学习程序</strong></p>
<p>回到上面举的例子，假设小花编写程序去自我训练下五子棋，程序训练了几万次，小花借助程序，和小白下棋赢的概率越来越高。那么经验E，就是程序自我训练，下的那几万局棋局；任务T呢，就是下五子棋；而度量手段P就是这个程序和小白下棋输赢的概率。</p>
<p>换句话说，之所以这个程序是机器学习程序，就是因为它通过经验E（训练自己下了几万局棋），在下棋这个任务T上，提升了自己的度量结果P（即赢小白的概率提升了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with respect to: 关于，至于，一种比较书面的用法</span><br><span class="line"></span><br><span class="line">例句：With respect to your inquiry, I enclose an explanatory leaflet.</span><br></pre></td></tr></table></figure>
<h2 id="supervised-learning-监督学习"><a href="#supervised-learning-监督学习" class="headerlink" title="supervised learning:监督学习"></a>supervised learning:监督学习</h2><p>监督学习是使用带有标记的数据集进行的学习。换句话说，我们知道一些数据的正确结果，想要得到更多的正确结果</p>
<p>举例1：小花发现自己在掉毛，为了预测自己掉毛的情况，他统计了过去一个月里，自己每天掉毛的数量。用此数据集来训练模型，预测未来自己掉毛的数量</p>
<p>这个例子是一个监督学习，在这个例子中，已有的数据集是有正确结果的。换句话说，上个月某天小花掉毛的数量是确定的。以此预测出下个月掉毛的数量是为了得到更多的正确结果。这样的问题也被称为回归问题</p>
<p>举例2：小花要送小白礼物，他认为小白的满意度和礼物的价格有关，于是他统计了过去自己送小白的礼物的价格和小白的满意度。以此训练模型来判断某种价格的礼物小白会不会喜欢</p>
<p>这个例子也是一个监督学习，在这个例子中，数据集里面某种价格的礼物是否被小白满意是确定的，有正确答案的。这个问题的实质是把某种价格的礼物分成两类，一类是小白满意，另一类是小白不满意，这样的问题也被称为分类问题</p>
<p>分类问题也可以有更多分类，还可以有更多的参数。比如小花觉得单凭价格无法衡量礼物的好坏，他还加上了礼物的质量，颜色，送礼物的时间等等。甚至可以有无限种参数</p>
<h2 id="unsupervised-learning-无监督学习"><a href="#unsupervised-learning-无监督学习" class="headerlink" title="unsupervised learning:无监督学习"></a>unsupervised learning:无监督学习</h2><p>无监督学习的数据集上是没有标记的。无分类学习往往希望机器能够自动地找出数据的结构和内在关联</p>
<p>举例：小花喜欢玩minecraft，游戏后期，众多物品堆满了大大小小的箱子。小花统计了物品的一些数据（如名字，堆叠数，是否方块，用途，使用频率等等），交给了机器学习算法。算法自动将一些相关的物品划分为一簇。把这些东西放置在同一个箱子里。比如金胡萝卜和烟花火箭都是常用的消耗品，红石和活塞因为经常一起用于做工程而关联密切等</p>
<p>小花在使用算法时，自己也不知道哪些东西和哪些东西关系比较密切，也不知道该划分成多少簇。这就是无监督学习。这种算法称为聚类算法</p>
<p>还有一个有意思的鸡尾酒算法：因为聚会上有很多人会一起说话，往往导致声音交杂在一起听不清，这时在一个聚会上放置两个录音机，因为说话的声音源和两个录音机的距离不同，所以可以用算法将不同声音源的声音分离出来</p>
<p>由于我们的数据集只有录音机录到的声音，我们事先也不知道有几个声音源，我们甚至都听不清具体他们说了什么，但把这样的数据集交给机器，机器自动地就能把它们分辨出来。这也是一个无监督学习</p>
<h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>我们考虑回归问题，小花统计自己掉毛的数量。我们可以想象他的数据是什么样的：首先有一个日期，然后是掉毛根数，类似于下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">日期		掉毛数/根</span><br><span class="line">1			253</span><br><span class="line">2			266</span><br><span class="line">3			275</span><br><span class="line">4			254</span><br><span class="line">5			291</span><br><span class="line">6			312</span><br><span class="line">……			……</span><br></pre></td></tr></table></figure>
<p>这样的一堆数据被称为数据集</p>
<p>本课程会用m来表示数据集的大小，例如小花统计了自己一个月31天的掉毛数据，这里的m=31</p>
<p>x是输入变量，这里表示日期</p>
<p>y是输出变量，这里表示掉毛数</p>
<p>注意在一些问题里，可能x，y是多维张量</p>
<p>(x, y)被称为一个训练样本，比如(1, 253)</p>
<p>一般使用上角标表示第i个训练样本，如x<sup>1</sup> = 1，y<sup>3</sup> = 275</p>
<p>学习算法的任务是：输出一个函数，这个函数将输入变量映射到输出变量上</p>
<p>比如小花的掉毛预测里，学习算法应该输出一个函数f，f以日期为输入，以掉毛数量为输出</p>
<p>一般会用h代表这个函数，而非f，原因是在机器学习的上古时代，研究者经常使用假设函数（hypothesis）这个名字，因此用h指代它的习惯一直保留了下来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hypothesis: 假设；假说</span><br><span class="line">例句：Work will now begin to test the hypothesis in rats</span><br></pre></td></tr></table></figure>
<p>我们需要在确定算法时，为h选定某种形式。比如规定h是一次函数h(x)=ax+b，或者是二次函数h(x)=ax<sup>2</sup>+bx+c……</p>
<p>当选定某种形式之后，势必要引入一些尚未确定的参数，一般不使用a，b，c，而是使用θ作为参数，当有多个参数时，习惯将θ添加下标</p>
<p>h也一般写为h<sub>θ</sub>(x)，有时也会缩写为h(x)</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>假设我们在上面的例子里使用一次函数的形式来定义假设函数h，即：</p>
<p>h(x) = θ<sub>0</sub> + θ<sub>1</sub>x</p>
<p>这里的θ<sub>0</sub>，θ<sub>1</sub>，以及未来可能在更复杂模型里出现的θ<sub>i</sub>被称为模型参数</p>
<p>这种模型被称为单变量线性回归</p>
<p>我们要做的就是恰当地选择所有θ<sub>i</sub>的值</p>
<p>怎样选择呢？我们知道一个好的模型应该是和实际结果基本一致的。换句话说，我们用数据集里面的x代入h<sub>θ</sub>(x)，得到的值应该和x对应的y值差得越小越好</p>
<p>那么问题来了，我们又如何评价预测值h(x)和实际值y的差值到底是大还是小呢</p>
<p>常见的方法是使用平方误差：</p>
<p>误差=Σ(h<sub>θ</sub>(x<sub>i</sub>) - y<sub>i</sub>)<sup>2</sup></p>
<p>这样就变成了一个最小值问题，即想办法求出参数集合θ<sub>i</sub>，使得误差最小</p>
<p>为了方便，我们定义代价函数(Cost Function): J(θ<sub>0</sub>, θ<sub>1</sub>)=Σ(h<sub>θ</sub>(x<sub>i</sub>) - y<sub>i</sub>)<sup>2</sup>/2m</p>
<p><img src="/images/机器学习入门课程笔记/0.png" alt></p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>使用梯度下降算法可以最小化任意函数，在这里，我们用于最小化代价函数J</p>
<p>θ<sub>j</sub>:=θ<sub>j</sub>-α * J(θ<sub>0</sub>, θ<sub>1</sub>)关于θ<sub>j</sub>的偏导数(for j = 0，1)</p>
<p>上面式子的:=是赋值号，α称之为学习率（learning rate），后面的偏导数就是梯度了</p>
<p>学习率太小会导致收敛速度太慢，学习率太大可能会导致一次次越过最低点，甚至无法收敛</p>
<p>如果初始值设置在最低点上，将不会更新</p>
<p>注意，θ<sub>0</sub>, θ<sub>1</sub>要同时更新，即都使用旧值先计算出它们的新值之后，再统一更新</p>
<h2 id="线性回归的梯度下降"><a href="#线性回归的梯度下降" class="headerlink" title="线性回归的梯度下降"></a>线性回归的梯度下降</h2><p>由于线性回归的平方误差函数总是凸函数，所以不必担心梯度下降法导致的可能陷入局部最优的问题</p>
<p>我们使用上面的梯度下降公式去实现线性回归的梯度下降，称之为Batch梯度下降（Batch Gradient Descent）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gradient 坡度，梯度</span><br><span class="line">例句：The courses are long and punishing, with steep gradients</span><br><span class="line">这些赛道又长又陡，具有挑战性</span><br><span class="line"></span><br><span class="line">descent 下降，下倾</span><br><span class="line">例句： There is a gradual descent to the sea. </span><br><span class="line">有一片斜坡延伸到海边</span><br></pre></td></tr></table></figure>
<p>Batch梯度下降每一步都遍历了整个数据集，有些梯度下降不是batch，意味着它们每一步并没有遍历整个数据集，而是遍历了子集</p>
<p>还有一种方法叫做正规方程组法，是使用数学方法直接解出最低点的值。梯度下降相比于正规方程组来说，更适合于大规模的数据集</p>
<h2 id="解决小花的掉毛问题"><a href="#解决小花的掉毛问题" class="headerlink" title="解决小花的掉毛问题"></a>解决小花的掉毛问题</h2><h3 id="读入-amp-读出数据集"><a href="#读入-amp-读出数据集" class="headerlink" title="读入&amp;读出数据集"></a>读入&amp;读出数据集</h3><p>因为是小花自己记录的数据，所以存在了一张excel表里</p>
<p>部分数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">日期	掉毛数量</span><br><span class="line">1	123</span><br><span class="line">2	142</span><br><span class="line">3	125</span><br><span class="line">4	157</span><br><span class="line">5	148</span><br><span class="line">6	169</span><br><span class="line">7	180</span><br><span class="line">8	176</span><br><span class="line">9	195</span><br><span class="line">10	200</span><br><span class="line">11	204</span><br><span class="line">12	209</span><br><span class="line">13	213</span><br><span class="line">14	224</span><br><span class="line">15	235</span><br><span class="line">16	244</span><br><span class="line">17	246</span><br><span class="line">18	257</span><br><span class="line">19	259</span><br><span class="line">20	275</span><br><span class="line">21	263</span><br><span class="line">22	269</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>读入读出excel表用的是python的openpyxl库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def read_excel():</span><br><span class="line">    filename = r&quot;D:\work\code\小花的掉毛问题\掉毛统计.xlsx&quot;</span><br><span class="line">    # r前缀表示raw string,不识别转义。</span><br><span class="line">    in_file = openpyxl.load_workbook(filename)  # 读文件</span><br><span class="line"></span><br><span class="line">    ws = in_file[in_file.sheetnames[0]]</span><br><span class="line"></span><br><span class="line">    # 获取sheet的最大行数和列数</span><br><span class="line">    rows = ws.max_row</span><br><span class="line">    cols = ws.max_column</span><br><span class="line">    print(rows, cols)</span><br><span class="line">    for r in range(1, rows + 1):</span><br><span class="line">        for c in range(1, cols + 1):</span><br><span class="line">            print(ws.cell(r, c).value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_excel():</span><br><span class="line">    out_file = openpyxl.Workbook()  # 打开一个将写的文件</span><br><span class="line">    sheet = out_file.active  # 在将写的文件创建sheet</span><br><span class="line">    sheet.title = &quot;sheet1&quot;</span><br><span class="line">    for row in range(1, 70):</span><br><span class="line">        for col in range(1, 4):</span><br><span class="line">            sheet.cell(row, col).value = row * 2  # 写文件</span><br><span class="line">    save_path = r&quot;D:\work\code\小花的掉毛问题\test.xlsx&quot;</span><br><span class="line">    out_file.save(save_path)  # 一定要记得保存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_excel()</span><br><span class="line">write_excel()</span><br></pre></td></tr></table></figure>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>为了让实验结果更直观一点，我们先学习一下怎么实现一些如绘制函数图像，绘制散点图这样基本的可视化功能</p>
<p>样例代码：绘制sigmoid函数图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">x = np.arange(-10, 10, 0.1)</span><br><span class="line">y = []</span><br><span class="line">for i in x:</span><br><span class="line">    y.append(1 / (1 + math.exp(-i)))</span><br><span class="line">plt.plot(x, y, label=&quot;sigmoid&quot;)</span><br><span class="line">plt.xlabel(&quot;x&quot;)</span><br><span class="line">plt.ylabel(&quot;y&quot;)</span><br><span class="line">plt.ylim(0, 1) #y的上下限</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><strong>np.arange()</strong></p>
<p>函数返回一个有终点和起点的固定步长的排列，如[1,2,3,4,5]，起点是1，终点是6，步长为1。(经典左闭右开)</p>
<p>参数个数情况：</p>
<p>一个参数时，参数值为终点，起点取默认值0，步长取默认值1</p>
<p>两个参数时，第一个参数为起点，第二个参数为终点，步长取默认值1</p>
<p>三个参数时，第一个参数为起点，第二个参数为终点，第三个参数为步长。其中步长支持小数</p>
<p>注意，返回的不是列表，转换为列表用list()</p>
<p><strong>plt.plot()</strong></p>
<p>传入x，y（均为数字集，可以是元组列表或者其它类型），绘制对应（x，y）连接的折线图</p>
<p>可以传入多组x，y，如plt.plot(x1, y1, x2, y2)，会画出两个图线</p>
<p>还有所谓传入二维数组和dateframe的方法，详见<a href="https://zhuanlan.zhihu.com/p/258106097" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/258106097</a></p>
<p>最后可以传入格式控制字符串，包括“颜色”，“点型”，“线型”</p>
<p>如plt.plot(x, y, “r–”)</p>
<p>表示r红色，–线形</p>
<p><img src="/images/机器学习入门课程笔记/1.png" alt></p>
<p>如果要指定点型</p>
<p>plt.plot(x, y, “r1:”)</p>
<p><img src="/images/机器学习入门课程笔记/2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">颜色字符</span><br><span class="line"></span><br><span class="line">    &apos;b&apos; 蓝色 &apos;m&apos; 洋红色 magenta</span><br><span class="line">    &apos;g&apos; 绿色 &apos;y&apos; 黄色</span><br><span class="line">    &apos;r&apos; 红色 &apos;k&apos; 黑色</span><br><span class="line">    &apos;w&apos; 白色 &apos;c&apos; 青绿色 cyan</span><br><span class="line">    &apos;#008000&apos; RGB某颜色 &apos;0.8&apos; 灰度值字符串</span><br><span class="line">    多条曲线不指定颜色时，会自动选择不同颜色</span><br><span class="line"></span><br><span class="line">风格字符</span><br><span class="line"></span><br><span class="line">    &apos;‐&apos; 实线</span><br><span class="line">    &apos;‐‐&apos; 破折线</span><br><span class="line">    &apos;‐.&apos; 点划线</span><br><span class="line">    &apos;:&apos; 虚线</span><br><span class="line">    &apos;&apos; &apos; &apos; 无线条</span><br><span class="line"></span><br><span class="line">标记字符</span><br><span class="line"></span><br><span class="line">    &apos;.&apos; 点标记</span><br><span class="line">    &apos;,&apos; 像素标记(极小点)</span><br><span class="line">    &apos;o&apos; 实心圈标记</span><br><span class="line">    &apos;v&apos; 倒三角标记</span><br><span class="line">    &apos;^&apos; 上三角标记</span><br><span class="line">    &apos;&gt;&apos; 右三角标记</span><br><span class="line">    &apos;&lt;&apos; 左三角标记...等等</span><br></pre></td></tr></table></figure>
<p>空格表示无线条，可以用来描绘散点图</p>
<p><img src="/images/机器学习入门课程笔记/3.png" alt></p>
<p>其它参数：</p>
<p>linewidth：线条宽度</p>
<p>color：颜色</p>
<p><a href="https://matplotlib.org/2.0.2/api/pyplot_api.html" target="_blank" rel="noopener">https://matplotlib.org/2.0.2/api/pyplot_api.html</a></p>
<p><strong>plt.legend()</strong></p>
<p>好像是给图像加上图例的</p>
<p><a href="https://blog.csdn.net/qq_37710333/article/details/108308155" target="_blank" rel="noopener">https://blog.csdn.net/qq_37710333/article/details/108308155</a></p>
<p>改成绘制两个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">x = np.arange(-10, 10, 1)</span><br><span class="line">y1 = []</span><br><span class="line">y2 = []</span><br><span class="line">for i in x:</span><br><span class="line">    y1.append(1 / (1 + math.exp(-i)))</span><br><span class="line">    y2.append(1 - 1 / (1 + math.exp(-i)))</span><br><span class="line">plt.plot(x, y1, x, y2, label=&quot;sigmoid&quot;)</span><br><span class="line">plt.xlabel(&quot;x&quot;)</span><br><span class="line">plt.ylabel(&quot;y&quot;)</span><br><span class="line">plt.ylim(0, 1)</span><br><span class="line">plt.legend([&quot;1&quot;, &quot;2&quot;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/机器学习入门课程笔记/4.png" alt></p>
<h3 id="读入小花的掉毛数据并绘制散点图"><a href="#读入小花的掉毛数据并绘制散点图" class="headerlink" title="读入小花的掉毛数据并绘制散点图"></a>读入小花的掉毛数据并绘制散点图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">path = r&quot;D:\work\code\小花的掉毛问题\掉毛统计.xlsx&quot;</span><br><span class="line">file_input = openpyxl.load_workbook(path)</span><br><span class="line">ws = file_input[file_input.sheetnames[0]]</span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line">for i in range(2, ws.max_row + 1):</span><br><span class="line">    x.append(ws.cell(i, 1).value)</span><br><span class="line">    y.append(ws.cell(i, 2).value)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, &quot;k1 &quot;)</span><br><span class="line">plt.xlabel(&quot;Day:&quot;)</span><br><span class="line">plt.ylabel(&quot;FurShedding::&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/images/机器学习入门课程笔记/5.png" alt></p>
<h3 id="分析回归算法"><a href="#分析回归算法" class="headerlink" title="分析回归算法"></a>分析回归算法</h3><p>大体的处理流程分以下几步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 设定参数初值，依据惯例，θ_0 = θ_1 = 0</span><br><span class="line">2. 根据当前两个θ的值，计算出平方误差函数关于两个参数的偏导数</span><br><span class="line">3. 更新参数的值，取步长为0.1</span><br><span class="line">4. 重复2</span><br></pre></td></tr></table></figure>
<p>所以，关键在于怎么求偏导数</p>
<h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><p>这个函数的偏导数比较简单，可以直接求，如果遇到更复杂的，可能就需要自己去使用数值方法求其偏导数了</p>
<p>复习一下数值分析的内容，学过的方法有差商公式和插值型求导公式两种</p>
<p>其实可以调用一些库函数去计算导数，但我暂时没找到可用的</p>
<p>所以，这次先自己求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def grad(x, y, m, theta):</span><br><span class="line">	g1 = 0</span><br><span class="line">    g2 = 0</span><br><span class="line">    for i in range(m):</span><br><span class="line">    	g1 += (theta[0] + theta[1] * x[i] - y[i])</span><br><span class="line">        g2 += (theta[0] + theta[1] * x[i] - y[i]) * x[i]</span><br><span class="line">    return g1 / m, g2 / m</span><br></pre></td></tr></table></figure>
<h3 id="代码实现和结果"><a href="#代码实现和结果" class="headerlink" title="代码实现和结果"></a>代码实现和结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def grad(x, y, m, theta):</span><br><span class="line">    g1 = 0</span><br><span class="line">    g2 = 0</span><br><span class="line">    for i in range(m):</span><br><span class="line">        g1 += (theta[0] + theta[1] * x[i] - y[i])</span><br><span class="line">        g2 += (theta[0] + theta[1] * x[i] - y[i]) * x[i]</span><br><span class="line">    return g1 / m, g2 / m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def load_data(path):</span><br><span class="line">    file_input = openpyxl.load_workbook(path)</span><br><span class="line">    ws = file_input[file_input.sheetnames[0]]</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    for i in range(2, ws.max_row + 1):</span><br><span class="line">        x.append(ws.cell(i, 1).value)</span><br><span class="line">        y.append(ws.cell(i, 2).value)</span><br><span class="line">    return x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_data(x, y, theta):</span><br><span class="line">    x2 = np.arange(0, 32, 1)</span><br><span class="line">    y2 = []</span><br><span class="line">    for i in x2:</span><br><span class="line">        y2.append(theta[0] + theta[1] * i)</span><br><span class="line">    plt.plot(x, y, &quot;r1 &quot;)</span><br><span class="line">    plt.plot(x2, y2, &quot;k-&quot;)</span><br><span class="line">    plt.xlabel(&quot;Day:&quot;)</span><br><span class="line">    plt.ylabel(&quot;FurShedding::&quot;)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    path = r&quot;D:\work\code\小花的掉毛问题\掉毛统计.xlsx&quot;</span><br><span class="line">    x, y = load_data(path)</span><br><span class="line">    theta = [0, 0]</span><br><span class="line">    rate = 0.001</span><br><span class="line">    train_time = 10000</span><br><span class="line">    m = len(x)</span><br><span class="line">    for i in range(train_time):</span><br><span class="line">        g1, g2 = grad(x, y, m, theta)</span><br><span class="line">        #print(g1, g2)</span><br><span class="line">        theta[0] -= rate * g1</span><br><span class="line">        theta[1] -= rate * g2</span><br><span class="line">        #print(theta[0], theta[1])</span><br><span class="line">    show_data(x, y, theta)</span><br></pre></td></tr></table></figure>
<p><img src="/images/机器学习入门课程笔记/6.png" alt></p>
<h3 id="学习率和训练次数"><a href="#学习率和训练次数" class="headerlink" title="学习率和训练次数"></a>学习率和训练次数</h3><p>一般来说，学习率太小会导致所需训练次数过多，学习率太大可能会导致不收敛的问题</p>
<p>之前的机器学习课上，我意识到了这个问题，却觉得无关紧要，因为对于一些复杂的模型来说，很难看到其背后运作的过程，以至于感觉这些参数无关紧要</p>
<p>但这次，由于模型比较简单，又是每一步都亲手实现的，所以可以看到参数不同引起的明显差别</p>
<p><img src="/images/机器学习入门课程笔记/7.png" alt></p>
<p>这是学习率为0.1，并训练了100次的结果，上面的两行是梯度，下面的两行是θ的两个值。可以看到都超乎寻常的大，这是怎么形成的呢？我们从最初的几次计算看起：</p>
<p><img src="/images/机器学习入门课程笔记/8.png" alt></p>
<p>可以看到第一次的梯度就已经几百几千了，虽然可能让人怀疑其真实性，但它确实是对的。因为第一次时，我们的参数都是0，这时候预测值和实际值差距较大是显然的，尤其是我们的数据单位基本都在几十几百上，所以算出这样的结果也不足为奇</p>
<p>但之后的几次就耐人寻味了，因为学习率设置为了0.1，这导致参数θ<sub>0</sub>变成了23，参数θ<sub>1</sub>变成了433。相当于预测函数变成了y=433x+23，这显然比刚刚的预测值差的更多。既然差得更多，计算出的梯度就会更大，进而更新后的参数会让结果差得更多更多，再算出的梯度又会更大更大，形成了恶性循环，最终越练越废</p>
<p><img src="/images/机器学习入门课程笔记/9.png" alt></p>
<p>上面的图是将学习率改成0.01之后的结果，可以看到最终也是发散了，原因还是一样，学习率太大</p>
<p>我们最终的结果采用的学习率是0.001，但收敛速度较慢，所以我们把它的训练次数改成了10000次</p>
<p>如果继续降低学习率呢？我认为，降低学习率总不是坏事，因为最差也不会出现发散的情况，但对于性能来说就不好保证了</p>
<p><img src="/images/机器学习入门课程笔记/10.png" alt></p>
<p>这是学习率为0.0001并训练了10000次的结果，可以看到它贴合样本数据的程度远不如我们上面给出的0.001并训练10000次的结果好</p>
<p>想要达到差不多的效果，我们训练的次数要成倍增加</p>
<p><img src="/images/机器学习入门课程笔记/11.png" alt></p>
<p>这张图是训练了十万次的结果，可以明显感觉到比上面的好多了</p>
<blockquote>
<p>所以，小花的掉毛问题就这样解决了。比较贴切的结果是y=111+7.6x，也就是说，基本上小花每天要多掉7.6根毛。掉毛的数量以等差数列的方式逐级递增，这样下去小花会秃的。为了不变成秃尾巴猫，小花还是多吃点黑芝麻丸好了</p>
</blockquote>
<h1 id="多元回归"><a href="#多元回归" class="headerlink" title="多元回归"></a>多元回归</h1><p>我们开始研究更复杂的回归问题，上篇文章里，我们讲到小花一直在为自己脱毛的事情苦恼，我们为了帮助他，训练出了自变量为日期，输出结果为脱毛数量的函数。</p>
<p>但这时候，小花会说，虽然他的脱毛情况是随着时间增加而越发严重的，上次的模型也很好地预测了未来的结果。但是，从常识来判断，时间肯定不是引发脱毛的因素。小花认为，最近掉毛可能和自己的学习时间，睡眠时间，蛋白摄入量，以及心情有关</p>
<p>于是，小花做了一张更详细的表，表中每一行有五列，分别是这天学习的时间/min，睡眠时间/min，蛋白质摄入量g/kg体重，心情指数0~5，脱毛根数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学习时间/min	睡眠时间/min	蛋白质/g·kg-1		心情		脱毛数/根</span><br><span class="line">246				475				1.05			5			120</span><br><span class="line">495				624				1.20			2			157</span><br><span class="line">800				350				1.40			1			320</span><br><span class="line">100				720				1.09			1			201</span><br></pre></td></tr></table></figure>
<p>对于这种数据集，m表示的还是样本数量，即行数。习惯使用上标来表示某个输入向量如x<sup>(2)</sup>表示四维向量[8， 10， 1.20， 2]</p>
<p>对于第i个样本的第j维度的值，常用的表示方法是i作为上标，j作为下标，即x<sup>i</sup><sub>j</sub></p>
<p>假设函数会变成什么样呢？</p>
<p>h<sub>θ</sub>(x)=θ<sub>0</sub>+θ<sub>1</sub>x<sub>1</sub>+θ<sub>2</sub>x<sub>2</sub>+θ<sub>3</sub>x<sub>3</sub>+θ<sub>4</sub>x<sub>4</sub></p>
<p>还是一个线性函数，为了用更简单的方式去表达它，我们假设输入变量还有一个维度是x<sub>0</sub>，并且它永远是1，这样原式就变成了：</p>
<p>h<sub>θ</sub>(x)=θ<sub>0</sub>x<sub>0</sub>+θ<sub>1</sub>x<sub>1</sub>+θ<sub>2</sub>x<sub>2</sub>+θ<sub>3</sub>x<sub>3</sub>+θ<sub>4</sub>x<sub>4</sub></p>
<p>然后，就可以写成向量乘积的方式，x是一个n+1维的向量，而参数θ同样也是n+1维的向量，它们的乘积导出了最终结果y值</p>
<h2 id="多元梯度下降法"><a href="#多元梯度下降法" class="headerlink" title="多元梯度下降法"></a>多元梯度下降法</h2><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>我们观察小花脱毛的表，可以看到学习时间和睡眠时间都是在一个比较大的数值范围内波动的，而蛋白质摄入量则变动很小</p>
<p>我们假设只关注二元变量，用睡眠时间和蛋白质摄入量作为输入，我们画出的等高线可能是这样的：</p>
<p><img src="/images/机器学习入门课程笔记/12.png" alt></p>
<p>可以看到同样的跨度上，等高线沿着蛋白质含量的变动比较剧烈，沿着睡眠时间的变动不太明显</p>
<p>那么很可能我们的梯度下降会出现图中折线的情况，因为等高线过于狭长，导致来回震荡而迟迟得不出结果</p>
<p>这种情况下，我们可以把特征值进行缩放，比如睡眠的尺度大概是0~800，蛋白质摄入量大概是0~1.5，可以把睡眠时间除以800，蛋白质摄入量除以1.5，所有变量都在-1~1之间，这样得到的等高线会更为圆润一些</p>
<p>还有一种常见的处理方式是中心正则化（mean normalize），把所有特征值归一到平均值是0的区间内</p>
<p>x=(x-均值)/标准差</p>
<h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p>画出代价函数随着迭代次数而变化的曲线，判断是否已经收敛</p>
<p>如果代价函数在渐渐增大，我们应该缩小学习率</p>
<p>忽大忽小的情况，也应该缩小学习率</p>
<p>尝试不同的学习率是梯度下降算法的常见方法</p>
<h3 id="特征和多项式回归"><a href="#特征和多项式回归" class="headerlink" title="特征和多项式回归"></a>特征和多项式回归</h3><p>如果把假设函数h设为二次方程，或者三次方程，比如y=ax<sup>2</sup>+bx+c，那么常见的做法是设x<sub>0</sub>=1，x<sub>1</sub>=x，x<sub>2</sub>=x<sup>2</sup>，然后再进行线性回归</p>
<p>这种情况下，特征缩放就变得极为重要了</p>
<h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><p>正规方程和迭代法不同，它可以直接解出最小值点</p>
<p>以多元回归问题的均方误差为例，为了使得：</p>
<p>J(θ<sub>0</sub>, θ<sub>1</sub>,……,θ<sub>n</sub>)=Σ(h<sub>θ</sub>(x<sup>(i)</sup>)-y<sup>(i)</sup>)<sup>2</sup>/2m</p>
<p>取得最小值，我们需要解出J关于所有θ的偏导均为0的方程组</p>
<p>解法：</p>
<p>θ=(X<sup>T</sup>X)<sup>-1</sup>X<sup>T</sup>y</p>
<p>推导过程：</p>
<p><img src="/images/机器学习入门课程笔记/0.jpg" alt></p>
<p>好处：如果我们使用正规方程，就不需要特征缩放了，也不需要设定合适的学习率</p>
<p>坏处：计算的时间复杂度大致会是n的三次方，所以特征维度太多时不合适</p>
<p>小细节：X<sup>T</sup>X不可逆怎么办，使用数值计算里的伪逆去算依然能够得到结果</p>
<p>不可逆的可能原因：</p>
<p>1.有几个特征之间存在线性关系</p>
<p>2.特征数n&gt;样本数m</p>
<h1 id="Octsve"><a href="#Octsve" class="headerlink" title="Octsve"></a>Octsve</h1><p>这一节讲的是OCTAVE，因其语法简单被用来做一些算法的测试版本</p>
<p>官网安装：<a href="http://www.gnu.org/software/octave/download" target="_blank" rel="noopener">http://www.gnu.org/software/octave/download</a></p>
<p>在windows下安装后会有一个命令行版本和一个带GUI的版本</p>
<p>在课程中，老师之所以推荐使用Octave的原因是我们在使用如同Java等语言具体实现某种算法时往往需要自己实现一些复杂的功能并耗费大量时间。Octave的优点是语法较为简单，实现常用的功能比较快速，这样可以在我们正式编程之前快速建立原型，节省时间</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>退出使用exit或者quit语句就可以退出</p>
<p>打开Octave终端，我们可以之间在里面输入表达式求值：</p>
<p><img src="/images/机器学习入门课程笔记/13.png" alt></p>
<p>我们同样可以做逻辑运算，用1表示真，0为假</p>
<p><img src="/images/机器学习入门课程笔记/14.png" alt></p>
<p>图中的%是注释符，大部分逻辑运算符类似于C，和C语言不同的有不等于~=，异或xor(a, b)，其它的遇到我们再说</p>
<p>下面是定义变量的做法，直接使用=就可以，非常方便</p>
<p><img src="/images/机器学习入门课程笔记/15.png" alt></p>
<p>可以看到从上往下我们分别定义了a，b（整形），c（字符串），d（布尔型）四个变量。我们在定义一个变量之后，会在接下来的一行自动把它的值打印出来，如果说我们不想让我们的指令引起任何输出的话，可以在指令末尾加分号；</p>
<p>我们想要打印已经定义过的某个变量的值，只需要直接输入变量名：</p>
<p><img src="/images/机器学习入门课程笔记/16.png" alt></p>
<p>这里pi是π</p>
<p>对于更复杂的输出，我们可以使用disp指令，比如我们想要保留两位小数，就可以使用：</p>
<p><img src="/images/机器学习入门课程笔记/17.png" alt></p>
<p>format long和format short命令可以转换默认的小数输出位数</p>
<p><img src="/images/机器学习入门课程笔记/18.png" alt></p>
<p>输入矩阵需要使用[]和;</p>
<p><img src="/images/机器学习入门课程笔记/19.png" alt></p>
<p>上面两种方法都是输入了一个3 × 2的矩阵</p>
<p>输入向量其实就是输入特殊的单行矩阵或单列矩阵</p>
<p><img src="/images/机器学习入门课程笔记/20.png" alt></p>
<p>上图中有两种特殊的产生行向量的写法，1:0.1:2是从步长为0.1，从1到2的闭区间，若省略步长，则默认使用1为步长</p>
<p><img src="/images/机器学习入门课程笔记/21.png" alt></p>
<p>ones()产生全1矩阵，可以使用乘法快速生成某个值的矩阵</p>
<p>zeros()产生全0矩阵，rand()产生范围是0~1的矩阵</p>
<p>randn()可以产生标准正态分布的随即值，可以使用统计学公式来产生任意均值和方差的正态分布序列</p>
<p><img src="/images/机器学习入门课程笔记/22.png" alt></p>
<p>上图中w是一个均值为12，方差为5的正态序列，hist指令可以画出它的直方图</p>
<p>可以绘制更多竖条的直方图</p>
<p><img src="/images/机器学习入门课程笔记/23.png" alt></p>
<p>使用eye指令可以画出单位阵</p>
<p><img src="/images/机器学习入门课程笔记/24.png" alt></p>
<p>help指令可以查看文档，比如help + rand，可以查看rand的文档（对非英语母语的人来说，可能help出来也看不懂吧，还得去网上找良莠不齐的教程，形形色色人写的博客）</p>
<p>使用size返回矩阵的大小，如：</p>
<p><img src="/images/机器学习入门课程笔记/25.png" alt></p>
<p>可以看到A是一个2 * 3的矩阵，使用size函数返回其大小是2 3，注意返回的值本身也是一个矩阵，这意味着我们同样可以使用size函数来处理先前size返回的值，现在得到的是1 2</p>
<p>length可以输出矩阵或向量最大维度的大小，比如：</p>
<p><img src="/images/机器学习入门课程笔记/26.png" alt></p>
<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>使用pwd可以查看当前路径</p>
<p><img src="/images/机器学习入门课程笔记/27.png" alt></p>
<p>使用cd来改变路径</p>
<p><img src="/images/机器学习入门课程笔记/28.png" alt></p>
<p>假设我们要导入的是当前文件夹里面的x.dat和y.dat两个文件中的数据，可以使用load命令</p>
<p><img src="/images/机器学习入门课程笔记/29.png" alt></p>
<p>load命令也可以用函数的方式</p>
<p><img src="/images/机器学习入门课程笔记/30.png" alt></p>
<p>怎么看到我们已经加载进来的变量呢？使用who命令</p>
<p><img src="/images/机器学习入门课程笔记/31.png" alt></p>
<p>在who命令的基础上，我们还可以加s，即whos命令，它能够为我们显示更详细的信息</p>
<p><img src="/images/机器学习入门课程笔记/32.png" alt></p>
<p>可以看到它以列表的形式输出了变量名，并给出了它们对应的size和占用内存，数据类型</p>
<p>想要去除某个变量，我们使用clear指令</p>
<p><img src="/images/机器学习入门课程笔记/33.png" alt></p>
<p>可以看到x被clear以后，已经从变量列表里面消失了</p>
<p>如果只输入了clear而不接任何参数，会直接清除所以工作区里的变量</p>
<p>使用(i:j)可以把第i到j个元素取出来</p>
<p><img src="/images/机器学习入门课程笔记/34.png" alt></p>
<p>想要存储变量，我们使用save指令</p>
<p><img src="/images/机器学习入门课程笔记/35.png" alt></p>
<p>可以看到，我们存储了三个变量到myvalues.mat，之后清除掉了所有变量，想要把三个变量再找出来，只需要load一下myvalues.mat就可以了</p>
<p>mat格式的文件会将所存储的变量进行一定的压缩，所以直接打开是看不懂的。如果不想把变量保存为mat格式的文件，可以将文件名改为txt后缀的文件，并在这一串命令的最后加上-ascii表示保存ascii码</p>
<h2 id="数据的操作"><a href="#数据的操作" class="headerlink" title="数据的操作"></a>数据的操作</h2><p>使用下标取出矩阵x第i行，第j列的值</p>
<p><img src="/images/机器学习入门课程笔记/36.png" alt></p>
<p>下标用()，同时是以1开始的</p>
<p>如果想要取出某一行或者某一列，可以使用:代替这一行或者一列的全部数值</p>
<p><img src="/images/机器学习入门课程笔记/37.png" alt></p>
<p>想要使用更复杂的方法，比如</p>
<p><img src="/images/机器学习入门课程笔记/38.png" alt></p>
<p>这样就取出了x的第一行和第四行</p>
<p>可以用这种取值方式去给x的部分元素赋值</p>
<p><img src="/images/机器学习入门课程笔记/39.png" alt></p>
<p>这里演示了比较复杂的几种方式，首先是取了x的前两行两列，赋值给了t，然后更改了t的第一行值，并给t追加了一列</p>
<p>如果只使用一个：，表示把整个矩阵变成一个列向量</p>
<p><img src="/images/机器学习入门课程笔记/40.png" alt></p>
<p>如果两个矩阵具有一样的行数，我们还可以直接连接它们</p>
<p><img src="/images/机器学习入门课程笔记/41.png" alt></p>
<p>如果使用分号，可以上下排列两个列数相同的矩阵</p>
<p><img src="/images/机器学习入门课程笔记/42.png" alt></p>
<p>使用，的写法和直接加空格一样，是左右连接</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>矩阵乘法可以直接使用*来表示</p>
<p><img src="/images/机器学习入门课程笔记/43.png" alt></p>
<p>除此之外，还可以使用.*来进行对应元素的乘法</p>
<p><img src="/images/机器学习入门课程笔记/44.png" alt></p>
<p>点号一般用于元素操作</p>
<p>要求两个操作对象的维度是一致的，但也有例外，如</p>
<p><img src="/images/机器学习入门课程笔记/45.png" alt></p>
<p>使用1 ./ A来取得A中每个元素的倒数组成的矩阵</p>
<p>log和exp表示取对数和以e为底求幂</p>
<p><img src="/images/机器学习入门课程笔记/46.png" alt></p>
<p>abs函数也同样</p>
<p>矩阵+1表示把矩阵中的每个元素都+1</p>
<p><img src="/images/机器学习入门课程笔记/47.png" alt></p>
<p>A的转置需要’</p>
<p><img src="/images/机器学习入门课程笔记/48.png" alt></p>
<p>max函数能够返回矩阵中每一列最大的元素值和其在对应列里的索引，如果只用一个变量接收，那么只会接收到这个最大值，如果使用两个，则会同时接收到最大值和索引</p>
<p><img src="/images/机器学习入门课程笔记/49.png" alt></p>
<p>想要找到每行的最大值该怎么做呢？使用max(A, [], 2)，这相当于找到A在第二个维度上的最大值。换句话说，如果A是更高阶的张量，这种方法也能找到更高维度上的最值</p>
<p><img src="/images/机器学习入门课程笔记/53.png" alt></p>
<p>如果使用&lt;进行比如A &lt; 2的运算，会将A中的元素依次和2比较，并将比较的结果放置在对应位置上产生新的布尔矩阵</p>
<p><img src="/images/机器学习入门课程笔记/50.png" alt></p>
<p>如果使用find(A&lt;2)，这会找出A中所有小于2的值</p>
<p><img src="/images/机器学习入门课程笔记/51.png" alt></p>
<p>如果用[r, c]去接收find函数的返回值，那么r会是所有A中符合要求元素的行索引构成的向量，c则是对应列</p>
<p>求和函数sum，求积函数prod，下取整函数floor，上取值函数ceil和max有类似的用法</p>
<p>比如sum(A, 1)可以求每一列的和组成的矩阵，sum(A, 2)则是求每一行的和</p>
<p>max也可以用来返回两个矩阵对应位置最大值组成的矩阵</p>
<p><img src="/images/机器学习入门课程笔记/54.png" alt></p>
<p>这里产生了两个随机的矩阵，然后取了对应位置的最大值</p>
<p>pinv是求逆，实际上是伪逆，因为它会对奇异矩阵求出逆</p>
<p>filpud是竖直翻转矩阵</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>plot函数可以绘制图像，类似于python</p>
<p><img src="/images/机器学习入门课程笔记/55.png" alt></p>
<p>当我们需要同时显示两个图像的时候，可以在第一次绘制出图像之后使用hold on命令令其不被顶替掉</p>
<p><img src="/images/机器学习入门课程笔记/56.png" alt></p>
<p>xlabel和ylabel是给x轴和y轴打标签的函数</p>
<p>使用legend来制作图例，比如上图可以使用</p>
<p><img src="/images/机器学习入门课程笔记/57.png" alt></p>
<p>再使用title函数可以指定图像的标题</p>
<p>保存图片的方法是：</p>
<p><img src="/images/机器学习入门课程笔记/58.png" alt></p>
<p>会保存在当前路径</p>
<p>可以通过给图像编号的方式来打开多个窗口的图像</p>
<p><img src="/images/机器学习入门课程笔记/59.png" alt></p>
<p>subplot函数可以把两个图像分开绘制在一个窗口上</p>
<p><img src="/images/机器学习入门课程笔记/60.png" alt></p>
<p>axis可以设置轴的范围</p>
<p>设置x为[0, 0.5]，y为[-1, 1]:</p>
<p><img src="/images/机器学习入门课程笔记/61.png" alt></p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>for循环</p>
<p><img src="/images/机器学习入门课程笔记/62.png" alt></p>
<p>循环的末尾要加end，类似地，while循环的写法是：</p>
<p><img src="/images/机器学习入门课程笔记/63.png" alt></p>
<p>在Octave里同样可以使用break和continue</p>
<p><img src="/images/机器学习入门课程笔记/64.png" alt></p>
<p>if语句类似，末尾也要加end</p>
<p>如果是ifelse语句，写法稍有不同</p>
<p><img src="/images/机器学习入门课程笔记/65.png" alt></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义函数需要先创建一个文本文件，名字是要定义的函数名，后缀以.m</p>
<p><img src="/images/机器学习入门课程笔记/66.png" alt></p>
<p>切换到该函数的目录下</p>
<p><img src="/images/机器学习入门课程笔记/67.png" alt></p>
<p>然后就可以使用了</p>
<p><img src="/images/机器学习入门课程笔记/68.png" alt></p>
<p>可以为Octave添加搜索路径，来在其它位置搜索函数</p>
<p><img src="/images/机器学习入门课程笔记/69.png" alt></p>
<p>可以看到即使不再桌面文件下，还是搜索到了f</p>
<p><img src="/images/机器学习入门课程笔记/70.png" alt></p>
<p>我们把函数改成这样，就可以返回两个值</p>
<p>接收方法是</p>
<p><img src="/images/机器学习入门课程笔记/71.png" alt></p>
<p>实际上函数还可以被设计地更复杂，我们假设需要一个计算之前J(θ)的函数，数据集为点(1, 1)(2, 2)(3, 3)，θ是0，1</p>
<p><img src="/images/机器学习入门课程笔记/72.png" alt></p>
<p>定义函数</p>
<p><img src="/images/机器学习入门课程笔记/73.png" alt></p>
<p>计算结果</p>
<p><img src="/images/机器学习入门课程笔记/74.png" alt></p>
<h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>使用向量化的实现方法会让代码更加简单，运行更加高效</p>
<h1 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h1><p>本节会讨论分类问题</p>
<p>邮件是否属于垃圾邮件，短信是不是骚扰短信，推测肿瘤是良性还是恶性等等。都是分类问题。</p>
<h2 id="线性回归分类"><a href="#线性回归分类" class="headerlink" title="线性回归分类"></a>线性回归分类</h2><p>我们举一个例子，假设小花统计了自己屡次给小白买的礼物价格和小白的满意程度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">价格					满意</span><br><span class="line">123					  0</span><br><span class="line">59					  0</span><br><span class="line">259					  1</span><br><span class="line">142					  1</span><br><span class="line">89					  0</span><br><span class="line">65					  0</span><br><span class="line">168					  1</span><br></pre></td></tr></table></figure>
<p>这里用0表示不满意，1表示满意</p>
<p>画出图像，使用之前的线性回归算法，我们可以得到类似于这样的图：</p>
<p><img src="/images/机器学习入门课程笔记/75.png" alt></p>
<p>蓝色的线就是假想函数，当然，这条线只是我随手画的，但实际上算法得出的函数也差不多。这个函数的使用方法是：我们先选取一个阈值，不妨为0.5，如果给我们一个价格p，我们使用这个函数取计算对应的y值，y大于0.5我们视为1，即满意，否则视为不满意</p>
<p>在这个例子中，线性回归似乎能够很好地解决我们的问题，它很完美地预测了小白的满意程度——大概高于130的礼物就可以让她满意。</p>
<p>但线性回归在某些数据集上就会出现问题，假如小花知道了价格越高的礼物小白越满意之后，连续给小白送了几件价格比较高的礼物，因此我们在上面数据集的基础上再加上几个点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">价格					满意</span><br><span class="line">123					  0</span><br><span class="line">59					  0</span><br><span class="line">259					  1</span><br><span class="line">142					  1</span><br><span class="line">89					  0</span><br><span class="line">65					  0</span><br><span class="line">168					  1</span><br><span class="line">350					  1</span><br><span class="line">475					  1</span><br><span class="line">399					  1</span><br></pre></td></tr></table></figure>
<p>这时的曲线会变成这样：</p>
<p><img src="/images/机器学习入门课程笔记/76.png" alt></p>
<p>现在我们发现，原本比较准确的模型不准了，因为新点的加入，曲线的中心点右移了很多，现在小白的满意阈值大概在200左右。</p>
<p>换句话说，我们可以看图上142和168两个点，即使实际情况是满意，但模型也会算出不满意的结果</p>
<p>这个例子我们可以看出来，线性回归不太适合做分类</p>
<h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>尽管logistic regression算法名字中带有回归(regression)，实际上它是用于分类的算法</p>
<p>首先我们需要知道sigmoid函数，或称之为logistic函数</p>
<p>f(z)=1/(1+e<sup>-z</sup>)</p>
<p>这个函数的特点是输出范围永远在(0, 1)，并关于(0, 0.5)对称</p>
<p>使用logistic函数对线性回归的结果进行处理，即假设函数为：</p>
<p>h(x) = 1/(1+e<sup>-θx</sup>)</p>
<p>这样，得到的值永远介于(0, 1)，我们可以将它解释为y=1的概率</p>
<p>接下来我们要做的事情是一样的，为θ选取一个合适的值</p>
<h3 id="决策边界-division-boundary"><a href="#决策边界-division-boundary" class="headerlink" title="决策边界(division boundary)"></a>决策边界(division boundary)</h3><p>在logistic回归里，凡是让z大于0的点我们都认为会让y=1，z小于0则y=0，而z是x的函数，在x构成的多维图像上，z=0这条曲线或曲面构成了一条分界，即决策边界</p>
<h3 id="参数拟合"><a href="#参数拟合" class="headerlink" title="参数拟合"></a>参数拟合</h3><p>首先，我们需要定义代价函数</p>
<p>在之前的线性回归中，我们定义了代价函数J，这里，我们把它写成更加一般的形式：</p>
<p>J(θ) = (1/m)Σ(cost(h<sub>θ</sub>(x<sup>i</sup>)), y<sup>i</sup>)</p>
<p>即代价函数等于每个样本的cost函数均值</p>
<p>在线性回归里，这个cost被定义为预测值和实际值的平方误差的一半</p>
<p>对于logistic回归的函数来说，如果继续使用预测值和实际值的平方误差作为代价，可能的结果是得到的函数J并不是一个凸函数</p>
<p>所以，对于logistic回归，我们使用的cost函数为：</p>
<p>cost(y, h)=-ylog(h)-(1-y)log(1-h)</p>
<p>这个式子来源于最大似然估计法</p>
<p>其梯度下降的更新公式为：</p>
<p>θ<sub>j</sub> = θ<sub>j</sub> - α(1/m)Σ{[h<sub>θ</sub>(x<sup>(i)</sup>)-y<sup>(i)</sup>]x<sup>(i)</sup><sub>j</sub>}</p>
<h2 id="解决礼物问题"><a href="#解决礼物问题" class="headerlink" title="解决礼物问题"></a>解决礼物问题</h2><h3 id="python非向量化实现"><a href="#python非向量化实现" class="headerlink" title="python非向量化实现"></a>python非向量化实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl</span><br><span class="line">import math</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def read(path):</span><br><span class="line">    in_file = openpyxl.load_workbook(path)</span><br><span class="line">    ws = in_file[in_file.sheetnames[0]]</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    for i in range(2, ws.max_row + 1):</span><br><span class="line">        x.append(ws.cell(i, 1).value)</span><br><span class="line">        y.append(ws.cell(i, 2).value)</span><br><span class="line">    return x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def h(theta, xj):</span><br><span class="line">    return math.exp(theta[0] + theta[1] * xj) / (1 + math.exp(theta[0] + theta[1] * xj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def train(x, y):</span><br><span class="line">    m = len(x)</span><br><span class="line">    theta = [0, 0]</span><br><span class="line">    alpha = 0.01</span><br><span class="line">    train_time = 30000</span><br><span class="line">    for i in range(train_time):</span><br><span class="line">        dlt1 = 0</span><br><span class="line">        for j in range(m):</span><br><span class="line">            dlt1 += (h(theta, x[j]) - y[j])</span><br><span class="line">        dlt1 /= m</span><br><span class="line">        t1 = theta[0] - alpha * dlt1</span><br><span class="line"></span><br><span class="line">        dlt2 = 0</span><br><span class="line">        for j in range(m):</span><br><span class="line">            dlt2 += (h(theta, x[j]) - y[j]) * x[j]</span><br><span class="line">        dlt2 /= m</span><br><span class="line">        t2 = theta[1] - alpha * dlt2</span><br><span class="line"></span><br><span class="line">        theta[0] = t1</span><br><span class="line">        theta[1] = t2</span><br><span class="line"></span><br><span class="line">    return theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_data(x, y, theta):</span><br><span class="line">    x2 = np.arange(0, 400, 1)</span><br><span class="line">    y2 = []</span><br><span class="line">    for i in x2:</span><br><span class="line">        y2.append(h(theta, i))</span><br><span class="line">    plt.plot(x, y, &quot;r1 &quot;)</span><br><span class="line">    plt.plot(x2, y2, &quot;k-&quot;)</span><br><span class="line">    plt.xlabel(&quot;Price:&quot;)</span><br><span class="line">    plt.ylabel(&quot;P:&quot;)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    x, y = read(r&quot;D:\work\code\小白的礼物问题\礼物统计.xlsx&quot;)</span><br><span class="line">    theta = train(x, y)</span><br><span class="line">    print(theta)</span><br><span class="line">    show_data(x, y, theta)</span><br></pre></td></tr></table></figure>
<p>注意的细节：</p>
<p>1.学习率的选择以及训练次数的选择</p>
<p>2.是否要进行特征缩放</p>
<p>上面代码最终实现的结果：</p>
<p><img src="/images/机器学习入门课程笔记/77.png" alt></p>
<h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><p>共轭梯度法(Conjugate gradient)，BFGS,L-BFGS</p>
<p>它们的一些特点是不需要手动设置学习率，能自动选择较好的学习率。收敛速度一般比梯度下降法要快。</p>
<p>这些算法的缺点是太复杂，以至于难以自己实现，必须借助一些库函数来完成</p>
<p>Octave中有比较好的库函数来实现它们。需要注意的是，即使是同一个函数，具体实现的细微差别仍然可能会影响到最终结果的好坏。因此，如果使用C或C++，Java，可能需要尝试几个不同的库才能更好地使用它们。</p>
<p>在Octave中如何使用这样的库函数呢</p>
<p>我们首先需要自己手动实现一个函数，传入参数，它返回两个值，第一个是代价函数，第二个是梯度向量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function [jVal, gradient] = costFunction(theta)</span><br><span class="line">jVal = ……</span><br><span class="line">gradient = ……</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以调用高级优化函数了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = optimset(&apos;GradObj&apos;, &apos;On&apos;, &apos;MaxIter&apos;, &apos;100&apos;);</span><br><span class="line">initialTheta = zeros(……);</span><br><span class="line">[optTheta, FunctionVal, exitFlag] = fminunc(@costFunction, options, initialTheta);</span><br></pre></td></tr></table></figure>
<p>options设置了一些选项，上面的是打开梯度目标函数，最大迭代次数100，initialTheta是初始参数值，调用时，@后是我们自己设置的函数指针</p>
<p>这里返回的三个值，其中optTheta是最终theta的值，functionval是取得最小值后的最小值，exitflag表示该函数是否已经收敛了。</p>
<h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>如果我们处理的问题有多个预测结果，比如小花的邮件可以分为正式事务的往来邮件，朋友之间的联系邮件，贺卡类邮件，验证消息，某些网站的通知，还有垃圾邮件等等。这时候，y值可以不仅仅有0和1两种，我们可能会使用0，1，2，3……等等更多的离散数据去表示不同的类别</p>
<p>现在我们处理多分类问题的方法比较简单，假设我们有0，1，2三种分类，我们会把0，1划分成一类，2分为另一类，将多分类问题化为单分类问题，得到假设函数h1，然后类似的，得到假设函数h2，h3，之后，对于一个新样本，我们会分别计算其h1，h2，h3的值，得到三种可能性，将可能性最大的那个拿出来视为最终结果</p>
<h2 id="Minst手写数据集分类"><a href="#Minst手写数据集分类" class="headerlink" title="Minst手写数据集分类"></a>Minst手写数据集分类</h2><h3 id="认识Minst手写数据集"><a href="#认识Minst手写数据集" class="headerlink" title="认识Minst手写数据集"></a>认识Minst手写数据集</h3><p>Minst手写数据集包含数个手写的数字图像和标签，每张图像由784个像素点组成，每张图像对应一个标签，这个标签表明该图像具体是哪个数字</p>
<p>官方下载地址：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p>
<p>包含四个压缩文件，其中带有train的两个文件分别是训练用的数据集和标签，不带train的是测试时用的</p>
<p>压缩文件以IDX文件格式存储，所以不能用图片编辑器打开</p>
<h3 id="手工解码idx格式"><a href="#手工解码idx格式" class="headerlink" title="手工解码idx格式"></a>手工解码idx格式</h3><p>官网上对雨idx格式有相应的介绍：</p>
<p>the IDX file format is a simple format for vectors and multidimensional matrices of various numerical types</p>
<p>idx文件格式是一种为了存储向量和多维矩阵等多种数值类型的简单格式</p>
<p>基本格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">magic number</span><br><span class="line">size in dimension 0</span><br><span class="line">size in dimension 1</span><br><span class="line">size in dimension 2</span><br><span class="line">.....</span><br><span class="line">size in dimension N</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>The magic number is an integer (MSB first). The first 2 bytes are always 0.</p>
<p>The third byte codes the type of the data:</p>
<p>魔数是一个整数，它前两个字节是0，第三个字节表明了数据的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x08: unsigned byte</span><br><span class="line">0x09: signed byte</span><br><span class="line">0x0B: short (2 bytes)</span><br><span class="line">0x0C: int (4 bytes)</span><br><span class="line">0x0D: float (4 bytes)</span><br><span class="line">0x0E: double (8 bytes)</span><br></pre></td></tr></table></figure>
<p>The 4-th byte codes the number of dimensions of the vector/matrix: 1 for vectors, 2 for matrices….</p>
<p>The sizes in each dimension are 4-byte integers (MSB first, high endian, like in most non-Intel processors).</p>
<p>The data is stored like in a C array, i.e. the index in the last dimension changes the fastest.</p>
<p>第4个字节编码向量/矩阵的维数：1表示向量，2表示矩阵。。。。</p>
<p>每个维度中的大小都是4字节整数（MSB优先，高端，与大多数非英特尔处理器一样）。</p>
<p>数据以C数组的形式存储，即最后一个维度中的索引变化最快。</p>
<p>具体解码代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">def decode_idx3_ubyte(idx3_ubyte_file):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    解析idx3文件的通用函数</span><br><span class="line">    :param idx3_ubyte_file: idx3文件路径</span><br><span class="line">    :return: 数据集</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 读取二进制数据</span><br><span class="line">    bin_data = open(idx3_ubyte_file, &apos;rb&apos;).read()</span><br><span class="line"></span><br><span class="line">    # 解析文件头信息，依次为魔数、图片数量、每张图片高、每张图片宽</span><br><span class="line">    offset = 0</span><br><span class="line">    fmt_header = &apos;&gt;iiii&apos;</span><br><span class="line">    magic_number, num_images, num_rows, num_cols = struct.unpack_from(fmt_header, bin_data, offset)</span><br><span class="line">    print &apos;魔数:%d, 图片数量: %d张, 图片大小: %d*%d&apos; % (magic_number, num_images, num_rows, num_cols)</span><br><span class="line"></span><br><span class="line">    # 解析数据集</span><br><span class="line">    image_size = num_rows * num_cols</span><br><span class="line">    offset += struct.calcsize(fmt_header)</span><br><span class="line">    fmt_image = &apos;&gt;&apos; + str(image_size) + &apos;B&apos;</span><br><span class="line">    images = np.empty((num_images, num_rows, num_cols))</span><br><span class="line">    for i in range(num_images):</span><br><span class="line">        if (i + 1) % 10000 == 0:</span><br><span class="line">            print &apos;已解析 %d&apos; % (i + 1) + &apos;张&apos;</span><br><span class="line">        images[i] = np.array(struct.unpack_from(fmt_image, bin_data, offset)).reshape((num_rows, num_cols))</span><br><span class="line">        offset += struct.calcsize(fmt_image)</span><br><span class="line">    return images</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def decode_idx1_ubyte(idx1_ubyte_file):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    解析idx1文件的通用函数</span><br><span class="line">    :param idx1_ubyte_file: idx1文件路径</span><br><span class="line">    :return: 数据集</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 读取二进制数据</span><br><span class="line">    bin_data = open(idx1_ubyte_file, &apos;rb&apos;).read()</span><br><span class="line"></span><br><span class="line">    # 解析文件头信息，依次为魔数和标签数</span><br><span class="line">    offset = 0</span><br><span class="line">    fmt_header = &apos;&gt;ii&apos;</span><br><span class="line">    magic_number, num_images = struct.unpack_from(fmt_header, bin_data, offset)</span><br><span class="line">    print &apos;魔数:%d, 图片数量: %d张&apos; % (magic_number, num_images)</span><br><span class="line"></span><br><span class="line">    # 解析数据集</span><br><span class="line">    offset += struct.calcsize(fmt_header)</span><br><span class="line">    fmt_image = &apos;&gt;B&apos;</span><br><span class="line">    labels = np.empty(num_images)</span><br><span class="line">    for i in range(num_images):</span><br><span class="line">        if (i + 1) % 10000 == 0:</span><br><span class="line">            print &apos;已解析 %d&apos; % (i + 1) + &apos;张&apos;</span><br><span class="line">        labels[i] = struct.unpack_from(fmt_image, bin_data, offset)[0]</span><br><span class="line">        offset += struct.calcsize(fmt_image)</span><br><span class="line">    return labels</span><br></pre></td></tr></table></figure>
<p>这里用到了python的struct模块，解析的主要函数是unpack_from</p>
<p>该函数接收三个函数，格式字符串，文件流，偏移量，返回元组</p>
<p>上面的格式字符串中‘&gt;iiii’表示以大端方式解析4个int型数据，‘&gt;B’表示以大端方式解析一个字节</p>
<p>struct.calcsize(fmt_header)是计算头信息占的大小，以便设置后面的offset</p>
<p>idx3表示存储的数据是三维张量，在这里，表示图片数×图片长×图片高，idx1则表示存储的数据是一维向量，表示每张图片对应的标签</p>
<h3 id="一点数学推导"><a href="#一点数学推导" class="headerlink" title="一点数学推导"></a>一点数学推导</h3><p>我们把每张图片看作一个向量，该向量由784个整数组成，每个图片添加维度，其值为常数1，这样，每组输入为785维向量</p>
<p>之后，共有m张图片，得到输入为m×785的矩阵</p>
<p>按照之前的模型，我们的参数θ个数应该是785</p>
<p>输出有10个结果，分别是这张图是0的概率，是1的概率，2的概率……，相当于有10个通道，为每个可能的概率，我们都需要一个对应的假想函数，也就是一组不同的参数θ</p>
<p>这样，参数θ实际上相当于也被扩展成了一个矩阵，其size为785×10</p>
<p>我们在计算时，首先会计算Xθ，得到一个m×10的值矩阵，再把它们全部代入logistic函数，得到m×10概率矩阵，再从m行里面挑选出每一列中最大的值的列号，得到最终m个数字组成的结果向量</p>
<h3 id="python的张量操作"><a href="#python的张量操作" class="headerlink" title="python的张量操作"></a>python的张量操作</h3><p>求幂np.exp()</p>
<p>改变尺寸reshape()</p>
<p>矩阵相乘Matrix.dot()//Matrix指的是矩阵名</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>dataloader.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def idx1_loader(filename):</span><br><span class="line">    bin_data = open(filename, &apos;rb&apos;).read()</span><br><span class="line">    offset = 0</span><br><span class="line">    fmt = &apos;&gt;ii&apos;</span><br><span class="line">    magic_number, size = struct.unpack_from(fmt, bin_data, offset)</span><br><span class="line"></span><br><span class="line">    labels = np.empty(size, int)</span><br><span class="line"></span><br><span class="line">    offset += struct.calcsize(fmt)</span><br><span class="line">    fmt = &apos;&gt;B&apos;</span><br><span class="line"></span><br><span class="line">    for i in range(size):</span><br><span class="line">        labels[i] = struct.unpack_from(fmt, bin_data, offset)[0]</span><br><span class="line">        offset += struct.calcsize(fmt)</span><br><span class="line"></span><br><span class="line">    y = np.zeros((size, 10))</span><br><span class="line">    for i in range(size):</span><br><span class="line">        y[i][labels[i]] = 1</span><br><span class="line"></span><br><span class="line">    return y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def idx3_loader(filename):</span><br><span class="line">    bin_data = open(filename, &apos;rb&apos;).read()</span><br><span class="line">    offset = 0</span><br><span class="line">    fmt = &apos;&gt;iiii&apos;</span><br><span class="line">    magic_number, image_number, row, col = struct.unpack_from(fmt, bin_data, offset)</span><br><span class="line"></span><br><span class="line">    offset += struct.calcsize(fmt)</span><br><span class="line">    fmt = &apos;&gt;&apos; + str(row * col) + &apos;B&apos;</span><br><span class="line"></span><br><span class="line">    images = np.empty((image_number, row * col))</span><br><span class="line"></span><br><span class="line">    for i in range(image_number):</span><br><span class="line">        images[i] = struct.unpack_from(fmt, bin_data, offset)</span><br><span class="line">        offset += struct.calcsize(fmt)</span><br><span class="line"></span><br><span class="line">    t = np.ones(image_number)</span><br><span class="line"></span><br><span class="line">    x = np.insert(images, 784, t, 1)</span><br><span class="line"></span><br><span class="line">    return x / 256.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    a = np.array([[1, 2, 3], [4, 5, 6]])</span><br><span class="line">    np.insert(a, 3, [1,1], 1)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>main.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import dataLoader</span><br><span class="line">import numpy as np</span><br><span class="line">import tqdm</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def load_data():</span><br><span class="line">    train_image_file = r&apos;D:\work\code\手写数据集分类\手写数据集\train-images.idx3-ubyte&apos;</span><br><span class="line">    train_label_file = r&apos;D:\work\code\手写数据集分类\手写数据集\train-labels.idx1-ubyte&apos;</span><br><span class="line">    test_image_file = r&apos;D:\work\code\手写数据集分类\手写数据集\t10k-images.idx3-ubyte&apos;</span><br><span class="line">    test_label_file = r&apos;D:\work\code\手写数据集分类\手写数据集\t10k-labels.idx1-ubyte&apos;</span><br><span class="line"></span><br><span class="line">    train_x = dataLoader.idx3_loader(train_image_file)</span><br><span class="line">    train_y = dataLoader.idx1_loader(train_label_file)</span><br><span class="line">    test_x = dataLoader.idx3_loader(test_image_file)</span><br><span class="line">    test_y = dataLoader.idx1_loader(test_label_file)</span><br><span class="line"></span><br><span class="line">    return train_x, train_y, test_x, test_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loss(hx, y):</span><br><span class="line">    res = 0</span><br><span class="line">    for i in range(len(y)):</span><br><span class="line">        for j in range(10):</span><br><span class="line">            if y[i][j] == 1:</span><br><span class="line">                res += math.log2(hx[i][j])</span><br><span class="line">            else:</span><br><span class="line">                res += math.log2(1 - hx[i][j])</span><br><span class="line">    return -res / len(y) / 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def h(theta, x):</span><br><span class="line">    z = np.exp(-(x.dot(theta)))</span><br><span class="line">    return 1 / (1 + z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dlt(theta, x, y):</span><br><span class="line">    hx = h(theta, x)</span><br><span class="line">    return x.T.dot(hx - y), loss(hx, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def train(train_time, alpha, x, y):</span><br><span class="line">    theta = np.zeros((785, 10))</span><br><span class="line">    for i in range(train_time):</span><br><span class="line">        total_loss = 0</span><br><span class="line">        print(&apos;第%d次训练：&apos; % (i + 1))</span><br><span class="line">        for j in tqdm.tqdm(range(len(x) // 100)):</span><br><span class="line">            tx = x[j * 100 : j * 100 + 100]</span><br><span class="line">            ty = y[j * 100 : j * 100 + 100]</span><br><span class="line">            d, l = dlt(theta, tx, ty)</span><br><span class="line">            theta -= alpha * d / 100</span><br><span class="line">            total_loss += l</span><br><span class="line">        print(&apos;loss: %f&apos; % (total_loss / len(x) * 100))</span><br><span class="line">    return theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(theta, x, y):</span><br><span class="line">    res = h(theta, x)</span><br><span class="line">    times = 0</span><br><span class="line">    for i in range(len(y)):</span><br><span class="line">        a = 0</span><br><span class="line">        b = 0</span><br><span class="line">        maxv = res[i][0]</span><br><span class="line">        for j in range(9):</span><br><span class="line">            if y[i][j + 1] == 1:</span><br><span class="line">                b = j + 1</span><br><span class="line">            if res[i][j + 1] &gt; maxv:</span><br><span class="line">                maxv = res[i][j + 1]</span><br><span class="line">                a = j + 1</span><br><span class="line">        times += y[i][a]</span><br><span class="line">    return times / len(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    train_x, train_y, test_x, test_y = load_data()</span><br><span class="line">    theta = train(1000, 0.3, train_x, train_y)</span><br><span class="line">    print(test(theta, test_x, test_y))</span><br></pre></td></tr></table></figure>
<p>需要注意的还是学习率和训练次数的选择，这里由于本地性能原因，训练次数不能太大，因此使用了比较大的学习率0.3，训练次数是1000次</p>
<p>而且，由于样本比较多，一次训练没有采用全部的数据，而是分成了100个一组。这也是由于本地性能的原因</p>
<p>还有一些有待改进的地方</p>
<p>最终训练结果：91.43%</p>
<h1 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h1><p><img src="/images/机器学习入门课程笔记/78.png" alt></p>
<p>上图中，中间的曲线很好的拟合了这五个点，而左边的曲线则被称为欠拟合，右边的曲线被称为过拟合</p>
<p>过度拟合可能会在变量较多的时候出现，这时，训练出的结果可能会在训练集上表现很好，计算出的代价函数可能会很趋近于0</p>
<p>通常情况下，有两种解决过拟合的方法，一种是人工筛查降低变量的个数，更高阶地，甚至有专门的模型选择算法来决定哪些变量应该保留，哪些变量应该舍弃。另一种是正则化，我们在下面讲到</p>
<h2 id="加入惩罚"><a href="#加入惩罚" class="headerlink" title="加入惩罚"></a>加入惩罚</h2><p>我们不妨假设左图使用了线性的假设函数，没有达到预期的效果，而中间的图使用了二次函数，效果最好，右边的图则添加了许多高次项</p>
<p>那么，有一种方法可以降低高次项的影响，假如我们有：</p>
<p>h = θ<sub>0</sub>x + θ<sub>1</sub>x + θ<sub>2</sub>x<sup>2</sup> + θ<sub>3</sub>x<sup>3</sup></p>
<p>那么，为了让三次项x<sup>3</sup>带来的影响尽量小，我们在代价函数里加入惩罚项θ<sub>3</sub><sup>2</sup></p>
<p>这样，当我们最小化代价函数J时，必然要将θ<sub>3</sub>控制的足够小</p>
<p>当某个参数值变小时，曲线会随着参数的值越小越平滑</p>
<p>换句话说，加入惩罚项是在简化模型</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>正则化的方法则是为每一项都加入惩罚，在原有的代价函数J的基础上，再增加一项</p>
<p>J’ = J + λΣθ<sup>2</sup> / 2m</p>
<p>λ是一个系数</p>
<p>这是因为我们也不知道哪个参数可能会引起过拟合，因此将它们全部适当减小</p>
<p>这样，在梯度下降时，我们同样要减去其导数λΣθ<sub>j</sub> / m</p>
<p>如果使用正规方程，则需要改动为θ=(x<sup>T</sup>x + λM)<sup>-1</sup>x<sup>T</sup>y</p>
<p>M是一个矩阵，类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1</span><br></pre></td></tr></table></figure>
<p>是一个n+1行的单位阵，把第一行第一列的1改为0</p>
<p>加入正则化矩阵之后还能解决之前的奇异矩阵问题</p>
<p>在高级优化函数中使用正则化：略</p>
<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>本节讨论神经网络</p>
<h2 id="为什么学习神经网络"><a href="#为什么学习神经网络" class="headerlink" title="为什么学习神经网络"></a>为什么学习神经网络</h2><p>假设小花还在头疼小白的礼物问题，这次包括价格在内，他统计了100个可能有关的特征值（比如颜色，种类，网络上的评价，体积，发货时间，知名度等等），我们仍然使用普通的sigmoid去处理100个特征值的分类问题</p>
<p>如果我们仅仅使用一次项，那么需要设定101个参数。但为了让结果更精确些，或许我们会考虑使用更高次的项如x<sub>1</sub>x<sub>2</sub>，x<sub>3</sub><sup>2</sup>等等，这样一来，想要使用所有的二次项，我们就需要再设定5000个参数</p>
<p>以此类推，三次项的数量级应该是O(n<sup>3</sup>)，事实上也是这样子的，我们想要应用三次项，需要设定100×99×98/3!那么多参数</p>
<p>显然，那么多参数对我们后续的运算会造成极大的负担。很多情况下是不现实的。</p>
<p>更一般的例子出现在计算机视觉领域。假设小花要在一堆照片中识别出鱼的图片，他需要做的是设计一个算法去处理这些由像素点组成的图片文件，然后将它们分类。但相较于我们之前学过的分类方法，图片的像素点实在是太多了，一张50×50像素的图片已经非常小了，但仍然相当于引入了2500个变量</p>
<h2 id="神经网络的计算方法"><a href="#神经网络的计算方法" class="headerlink" title="神经网络的计算方法"></a>神经网络的计算方法</h2><p>我们怎么去理解神经元？我们知道，一个神经元最主要的功能无非三点，接收数据，处理数据，发送数据</p>
<p>这里的数据也可以理解为某种信号</p>
<p>举个例子，或许我们可以把上面的礼物问题的100个特征值看作100个神经元，这100个神经元是特殊的，因为他只是单纯的把数据输入进来，不做任何处理，我们称之为输入层</p>
<p>接下来，我们可能把这些输入接到其它神经元上。比如有一个神经元，它接收第一个神经元的数据，然后对其放大三倍，再输出出去</p>
<p>我们可以根据自己的算法接入多种不同的神经元，进行进一步的数据处理</p>
<p>最终，我们把结果输出到最后一层的神经元，这一层被称为输出层，它只接收，不处理，也不继续输出</p>
<p>处理输入和输出层之外的神经元都进行了接收，处理，输出的过程，这些神经元被称为隐藏层。</p>
<p><img src="/images/机器学习入门课程笔记/79.png" alt></p>
<h2 id="用神经网络进行分类"><a href="#用神经网络进行分类" class="headerlink" title="用神经网络进行分类"></a>用神经网络进行分类</h2><p>一般使用L来表示神经网络中的层数</p>
<p>使用s<sub>l</sub>来表示第l层的节点数（不包括永远为1的偏振节点）</p>
<p>神经网络分类的代价函数，多分类问题中，把每个y的对应代价相加，并加上所有参数的正则化和</p>
<p><img src="/images/机器学习入门课程笔记/80.png" alt></p>
<h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p><img src="/images/机器学习入门课程笔记/81.png" alt></p>
<p>为了计算每一层参数的偏导数，我们采用反向传播算法</p>
<p>反向传播，是从最后一层的偏差值开始算起，反向推出每一层的偏差，以此来优化每一层的参数</p>
<p>实际上是链式法则的应用，不再逐步推导</p>
<p>只需要知道，上面的(θ<sup>(3)</sup>)<sup>T</sup>δ<sup>(4)</sup>是第四层的δ<sup>(4)</sup>对第三层的每个z的偏导数构成的向量，之后乘的g’(z)一项实际上是再对α求导，总体上是一个链式法则</p>
<p>要理解它，我们不妨假设最终的交叉熵损失函数是J，然后我们对某一层的参数求偏导，需要先求出J关于前一层输入的导数，再继续求出再前一层，以此类推，直到该参数的后一层，然后对该参数求导</p>
<p>这样做的好处是重复使用每一层求导得到的中间结果，明显减少计算量</p>
<h2 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h2><p>反向传播算法往往会导致细节上的bug，甚至于我们都无法得知实际上模型的训练结果是由bug导致的，为此，梯度检验就是一种很好的方法</p>
<p>当参数θ是一个实数的时候，我们可以使用求差分的方法去近似得到它的导数</p>
<p>即：[J(θ+ε)-J(θ-ε)]/2ε</p>
<p>当θ是一个向量的时候，我们需要更一般的表达式，一种简单的方法是对每个θ<sub>j</sub>求偏导数（用上面的差分公式去近似）</p>
<p>这样，我们想要检验反向传播的结果对不对时，只需要检测一下计算出的梯度是不是近似相等就好了。如果它们近似相等，我们有足够的理由相信，反向传播算法在做正确的事情</p>
<p>但值得注意的是，这种近似方法的计算速度是非常慢的，我们可以在几次训练中插入一到两次来检验，但不要次次都去比较，否则可能会导致整个算法非常非常慢</p>
<h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>在之前的回归模型中，我们一般把参数的初始值都设为0。在神经网络的模型中，这会有什么问题呢？</p>
<p><img src="/images/机器学习入门课程笔记/82.png" alt></p>
<p>我们拿上面这个潦草的示意图来打比方，假设我们把两条红线上的权值w1和w2都设为0，这会导致什么呢？</p>
<p>因为其它的权值也都是0，所以，实际上我们求导得到的梯度是一样的，两条红线是一样的，两条蓝线是一样的，两条黄线是一样的（想想这是为什么）</p>
<p>我们更新的时候，因为导数一样，我们就会更新为一样的值，那么，更新完，同一节点出发的两条线的权值还是一样的</p>
<p>更糟糕的是，再用新的值去计算新导数，我们又能得到一样的导数值，再更新之后，它们还是一样的！</p>
<p>所以，我们需要随机初始化</p>
<p>（因为我不知道这一点，我浪费了一天时间去苦恼为什么自己的多层感知机不能得到理想的结果）</p>
<h2 id="简单的手写数据集分类"><a href="#简单的手写数据集分类" class="headerlink" title="简单的手写数据集分类"></a>简单的手写数据集分类</h2><p>只做了一层隐藏层100个隐藏节点，最后的结果一直稳定在80%左右。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import dataloader</span><br><span class="line">import constants</span><br><span class="line">import net</span><br><span class="line">import tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def train(net1, train_x, train_y, test_x, test_y, time, batch, alpha):</span><br><span class="line">    for i in range(time):</span><br><span class="line">        print(&apos;%dth time:&apos; % (i + 1))</span><br><span class="line">        loss = 0</span><br><span class="line">        for j in tqdm.tqdm(range(len(train_x) // batch)):</span><br><span class="line">            x = train_x[j * batch: (j + 1) * batch]</span><br><span class="line">            y = train_y[j * batch: (j + 1) * batch]</span><br><span class="line">            for k in range(batch):</span><br><span class="line">                net1.forward(x[0])</span><br><span class="line">                net1.bk(y[0])</span><br><span class="line">                loss += net1.loss(y[0]) / len(train_x)</span><br><span class="line">            net1.update(batch, alpha)</span><br><span class="line">            net1.set_grad_zerp()</span><br><span class="line">        print(&apos;loss: %f&apos; % (loss))</span><br><span class="line">        print(test(net1, test_x, test_y))</span><br><span class="line">    return net1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test(net1, x, y):</span><br><span class="line">    rate = 0</span><br><span class="line">    for i in range(len(x)):</span><br><span class="line">        net1.forward(x[i])</span><br><span class="line">        maxv = net1.alpha2[0]</span><br><span class="line">        maxp = 0</span><br><span class="line">        for j in range(len(net1.alpha2) - 1):</span><br><span class="line">            if net1.alpha2[j] &gt; maxv:</span><br><span class="line">                maxv = net1.alpha2[j]</span><br><span class="line">                maxp = j</span><br><span class="line">        if y[i][maxp] == 1:</span><br><span class="line">            rate += 1</span><br><span class="line">    return rate / len(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    train_x = dataloader.idx3_loader(constants.TRAIN_X_FILE)</span><br><span class="line">    train_y = dataloader.idx1_loader(constants.TRAIN_Y_FILE)</span><br><span class="line">    test_x = dataloader.idx3_loader(constants.TEST_X_FILE)</span><br><span class="line">    test_y = dataloader.idx1_loader(constants.TEST_Y_FILE)</span><br><span class="line"></span><br><span class="line">    net1 = train(net.Net(), train_x, train_y, test_x, test_y, 50, 10, 0.1)</span><br></pre></td></tr></table></figure>
<p>net.py，自己实现了前向传播和反向传播</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Net:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.alpha0 = np.zeros(785)</span><br><span class="line">        self.z1 = np.zeros(100)</span><br><span class="line">        self.alpha1 = np.zeros(101)</span><br><span class="line">        self.z2 = np.zeros(10)</span><br><span class="line">        self.alpha2 = np.zeros(10)</span><br><span class="line"></span><br><span class="line">        #self.theta01 = np.zeros((785, 100))</span><br><span class="line">        #self.theta12 = np.zeros((101, 10))</span><br><span class="line"></span><br><span class="line">        self.theta01 = np.random.randn(785, 100)</span><br><span class="line">        self.theta12 = np.random.randn(101, 10)</span><br><span class="line"></span><br><span class="line">        self.grad01 = np.zeros((785, 100))</span><br><span class="line">        self.grad12 = np.zeros((101, 10))</span><br><span class="line"></span><br><span class="line">    def update(self, batch, alpha):</span><br><span class="line">        self.theta01 -= alpha * self.grad01 / batch</span><br><span class="line">        self.theta12 -= alpha * self.grad12 / batch</span><br><span class="line"></span><br><span class="line">    def set_grad_zerp(self):</span><br><span class="line">        self.grad01 = np.zeros((785, 100))</span><br><span class="line">        self.grad12 = np.zeros((101, 10))</span><br><span class="line"></span><br><span class="line">    def forward(self, inp):</span><br><span class="line">        self.alpha0 = inp</span><br><span class="line">        self.z1 = self.alpha0.dot(self.theta01)</span><br><span class="line">        t1 = np.exp(self.z1)</span><br><span class="line">        self.alpha1 = np.insert(t1 / (1 + t1), 0, 1, 0)</span><br><span class="line">        self.z2 = self.alpha1.dot(self.theta12)</span><br><span class="line">        t2 = np.exp(self.z2)</span><br><span class="line">        self.alpha2 = t2 / (1 + t2)</span><br><span class="line"></span><br><span class="line">    def bk(self, outp):</span><br><span class="line">        d2 = (self.alpha2 - outp).reshape(1, 10)</span><br><span class="line">        self.grad12 += self.alpha1.reshape(101, 1).dot(d2)</span><br><span class="line">        d1 = np.delete(d2.dot(self.theta12.T), 0, 1)</span><br><span class="line">        self.grad01 += self.alpha0.reshape(785, 1).dot(d1)</span><br><span class="line"></span><br><span class="line">    def loss(self, y):</span><br><span class="line">        res = 0</span><br><span class="line">        for i in range(len(y)):</span><br><span class="line">           res -= y[i] * np.log2(self.alpha2[i])</span><br><span class="line">           res -= (1 - y[i]) * np.log2(1 - self.alpha2[i])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p>dataloader和之前手写数据集的一样，还有一个constant文件存数据集的路径</p>
<p>最终的80%我感觉是模型本身太过简单吧，无论怎么调整参数和学习率，最终都维持在这个值左右</p>
<p>说实话有点失望，毕竟单纯的sigmoid还有90%左右的准确率</p>
<h1 id="机器学习诊断法"><a href="#机器学习诊断法" class="headerlink" title="机器学习诊断法"></a>机器学习诊断法</h1><p>如果你的模型不太准确，怎么办？</p>
<p>1.获取更多的样本</p>
<p>2.调整参数的数量</p>
<p>3.调整正则化权重</p>
<p>这些方法或许都会发挥它的作用，改善我们模型的性能，但也有可能并没有显著的成果。有的时候，人们常常随便选择一种方达去做，企图改善他们的结果，但很有可能花了大量的时间，结果却并不理想</p>
<p>这一节将讨论该怎么样评估算法的性能，并且如何去改善算法</p>
<p>这节的内容也被称为：机器学习诊断法。这种所谓的诊断法通常是一种测试，通过这样的测试，我们可以知道自己的算法哪里出了问题</p>
<h2 id="评估假设"><a href="#评估假设" class="headerlink" title="评估假设"></a>评估假设</h2><p>我们的模型是否过拟合呢？或许我们可以把模型的曲线和样本散点图画出来比较。但对于样本维度较多的情况，这种方法似乎不太现实。</p>
<p>一种方法是把训练样本分成训练集和测试集，通常来说，它们的比例是7：3</p>
<p>然后，使用测试集上的数据来计算J，即计算误差</p>
<p>J是我们常用的平方误差函数或者交叉熵损失函数等，J越大，说明模型越差</p>
<h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>我们要用几个特征呢？最高要用到几次呢？正则化参数的值选择多少呢？</p>
<p>这样的问题被称为模型选择问题，一般为了解决这种问题，会把样本分为训练，测试，验证三个部分</p>
<p>假如我们有10个模型，分别是一次函数，二次函数……一直到十次函数。相当于我们需要选择一个d值，这个d对应模型的次数。怎么选择呢？</p>
<p>我们分别用1~10次函数的10个模型去拟合样本，得到十个参数向量θ</p>
<p>然后对每个参数集和假设，分别求出它们在测试集上的J，J越小的，显然模型越好</p>
<p>到这里似乎问题就解决了，那么还要验证集干什么呢？</p>
<p>我们前面说了过拟合问题，其实就是参数过分拟合了训练集的某些特征，导致泛化能力不强，所以我们专门安排一个测试集去评估模型的性能。</p>
<p>那么我们上面的一套操作可以得到合适的d，相当于在测试集上拟合出了最好的d值，d会不会也过分拟合了测试集的某些特征呢？如果是，我们接下来在正式的训练时，测出的性能就不准确了</p>
<p>所以，我们最好不要用测试集找出最好的d，而是再划分出一部分，叫做验证集，用验证集去得到d，再用测试集去评估模型的性能。一般来说，训练/测试/验证集的比例是6/2/2</p>
<h2 id="偏差和方差"><a href="#偏差和方差" class="headerlink" title="偏差和方差"></a>偏差和方差</h2><p>过拟合也可以看作是方差问题，而欠拟合则是偏差问题</p>
<p>一般来说，随着我们选择的模型越发复杂，我们在训练集上的误差函数得到的值会越来越小</p>
<p>如果我们画出训练集上J值随着d变化的图像，可能会是单调递减的</p>
<p>而对于测试集上的J值，可能会是一个U型曲线，意味着一开始，随着d的增大，模型表现的越来越好，然后到达某个最好的值之后，又因为过拟合而越发偏离</p>
<p>所以，如果在测试集上误差和训练集上的差不多，都很大，说明是欠拟合问题，如果训练集上误差很小，但测试集上很大，说明是过拟合</p>
<h3 id="正则化-1"><a href="#正则化-1" class="headerlink" title="正则化"></a>正则化</h3><p>正则化参数的大小会对我们的偏差和方差产生很大的影响。假设我们有很小的正则化参数，那么我们最终训练出的模型会更倾向于过拟合。如果相反，我们有比较大的正则化参数，那么我们最终训练出的模型可能会倾向于欠拟合</p>
<p>那么怎么选择我们的正则化参数λ呢？</p>
<p>我们预先选取一系列的候选值</p>
<p>接下来做的事情就像确定d时一样，我们分别使用这些候选值在训练集上得到不同的θ，然后使用验证集去评估模型的性能</p>
<h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>如果我们画出训练误差和训练集大小的关系曲线，我们会发现一般随着样本数量的增多，训练误差会越来越大</p>
<p>对于交差验证误差，由于我们的样本数量越大，我们才越有可能得到泛化能力强的模型，所以交叉验证误差会随着样本数量的增多而减小</p>
<p>在欠拟合的情况下，由于模型能力的局限，随着样本数量的不断增加，两个误差会变得越发接近</p>
<p>在过拟合的情况下，由于模型总是在训练集上表现的更好，所以最终两个误差会有一个明显的界限差别</p>
<h2 id="接下来做什么"><a href="#接下来做什么" class="headerlink" title="接下来做什么"></a>接下来做什么</h2><p>说了这么多，我们回到最开始的问题，我们的模型表现的不好，我们该做什么呢？</p>
<p>1.获取更多的样本</p>
<p>2.调整参数的数量</p>
<p>3.调整正则化权重</p>
<p>1适合于高偏差问题，增加参数数量和减小正则化权重用于高偏差问题，反之则用于高方差问题</p>
<p>我们可以通过绘制学习曲线等方法去看我们的模型出了什么问题，当然，这会花费很长时间</p>
<h1 id="得出有效的模型"><a href="#得出有效的模型" class="headerlink" title="得出有效的模型"></a>得出有效的模型</h1><p>如果我们要研究某个机器学习系统，我们该做些什么呢？该怎么一步一步得到尽可能有效的模型呢？</p>
<p>一个简单的方法是，先在已有数据的基础上，利用简单的模型去做，画出学习曲线，并分析有没有方差问题，偏差问题……</p>
<p>对于算法出错的那部分数据，我们要手动分类并总结这些数据集之所以被错误分类的原因，总结出它们可能有的特征，以此为依据添加/减少特征</p>
<h2 id="偏斜类"><a href="#偏斜类" class="headerlink" title="偏斜类"></a>偏斜类</h2><p>在所有人构成的样本中，癌症患者占比是比较少的。假设我们预测某人是不是癌症患者的模型准确率达到99%，听上去是一个相当不错的算法，但是实际上可能真正的癌症患者只有0.5%，换句话说，我们仅仅是胡乱地认为所有人都没有癌症，这个胡乱模型的准确率也达到了99.5%</p>
<p>对于偏斜类，利用验证集得到的准确率并非一个好的评估方式</p>
<p>有一种方式，我们把这种偏差集分为真阳性，假阳性，真阴性，假阴性四个部分</p>
<p>计算查准率和召回率，它们分别是所有真阳性占模型预测的阳性的比率，和所有真阳性占实际上是阳性的比率</p>
<h2 id="精确率和召回率的权衡"><a href="#精确率和召回率的权衡" class="headerlink" title="精确率和召回率的权衡"></a>精确率和召回率的权衡</h2><p>一般地，上面的模型会输出某人得癌症的几率，我们一般会设定一个阈值，通常是0.5，来划分具体此人是否得了癌症</p>
<p>假如我们将没有得癌症的人诊断为了癌症患者，这样的后果是很严重的。因为癌症患者通常要做很多痛苦的治疗，并且会在精神上承受极大的压力。因此，为了降低可能的误诊情况，我们把阈值上调，比如0.7</p>
<p>换句话说，只有我们非常确信此患者得了癌症的时候，我们才会下结论</p>
<p>这样，这个模型就有了比较高的查准率，但相应的，也拥有了比较低的召回率</p>
<p>同样，如果我们希望高的召回率，可以设定较低的阈值比如0.3，但这时会导致较低的查准率</p>
<p>我们怎么权衡它们两个呢？</p>
<p>一般采用调和平均值2p1p2/(p1+p2)</p>
<h2 id="数据问题"><a href="#数据问题" class="headerlink" title="数据问题"></a>数据问题</h2><p>为什么大数据是重要的？</p>
<p>早期研究表明，不论何种算法，给予足够多的数据，总能得到更好的结果。并且数据足够多的情况下，算法之间的偏差并不明显</p>
<p>如何理解这一事实呢？我们注意到，一个好的算法通常是没有高方差，也没有高偏差的。意味着当我们的参数足够多时，往往能较好的拟合数据集，具有低偏差。而此时的数据集如果足够大，我们的方差也通常不会太大。</p>
<p>这也就意味着，如果数据集足够精准，并且提供的参赛值足够我们预测出结果。我们总能得到比较好的模型</p>
<h1 id="支持向量机SVM"><a href="#支持向量机SVM" class="headerlink" title="支持向量机SVM"></a>支持向量机SVM</h1><p>在之前的logistic回归里，我们使用了以下的代价函数</p>
<p>J(θ) = (1/m)Σ(ylog(h)+(1-y)log(1-h))+(λ/2m)Σ(θ<sup>2</sup>)</p>
<p>而当y=1时，我们知道代价函数的值会随着h值的变化而变化</p>
<p><img src="/images/机器学习入门课程笔记/83.png" alt></p>
<p>这张图是J关于z值的粗略图。可以看到，在y=1而z值比较大时，h值会接近1，J会很小。反之则很大。</p>
<p>在支持向量机的定义中，把这个图像划分为两部分，既然z越大对J的影响越小，干脆z处于一个比较大的区间时，之间规定此时对J的贡献是0</p>
<p>而另一边，z小时，把J和z的关系改为线性函数</p>
<p>同样，对于y=0的另一半边，我们也采用这样的处理方式</p>
<p>J(θ) = (1/m)Σ(ycost<sub>1</sub>(z)+(1-y)cost<sub>0</sub>(z))+(λ/2m)Σ(θ<sup>2</sup>)</p>
<p>习惯上，SVM经常把J写作：</p>
<p>J=CA+B</p>
<p>A是cost函数的和，C是常数，B是正则化项</p>
<h2 id="大间距"><a href="#大间距" class="headerlink" title="大间距"></a>大间距</h2><p>我们希望在SVM中，当y=1时有z&gt;1，y=0时有z&lt;-1，这样把z代入sigmoid函数后得到的值会有一个间距</p>
<p>这相当于可以找到一条更好的决策边界</p>
<p><img src="/images/机器学习入门课程笔记/84.png" alt></p>
<p>当C值非常大时，这种大间距的分类方式会对一两个异常点非常敏感。当C比较小的时候，算法就可以正确地忽略异常点</p>
<p><img src="/images/机器学习入门课程笔记/85.png" alt></p>
<p>为了更好的理解，我们可以先考虑决策边界和参数的关系，显然它们是垂直的，图中决策边界是绿色的线，那么参数就是蓝色的向量，指向正样本</p>
<p>在这个不太好的决策边界和参数下，可以看到任何一个样本和向量的内积不会特别大，假设有一个正样本，它和参数的内积z是正的，但z不会特别大。不过我们规定了z的要求，因此z值必须显著地大于1才行，所以唯一的方法是参数的模比较大，但这又违反了正则化项的要求</p>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>定义新的特征向量f<sub>1</sub>, f<sub>2</sub>……</p>
<p>对于一个点p(x,y)，我们把特征向量f&gt;sub&gt;i和点l<sup>(i)</sup>绑定在一起，定义f<sub>i</sub>的值为p与l<sup>(i)</sup>的相似度，计算这个相似度的函数就是核函数</p>
<p>取高斯核函数exp(-||p-l<sup>(i)</sup>||/2σ<sup>2</sup>)</p>
<p>这样，就可以取得新的特征值</p>
<p>那么，标记点l怎么取呢？简单的方法是，训练集里的数据点x就是标记点l</p>
<p>这样，每个样本进入模型，第一步会被转化为m+1维向量f，m是样本大小，然后再核m+1维参数θ相乘……</p>
<h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><p><img src="/images/机器学习入门课程笔记/86.png" alt></p>
<p>数据集中不再带有标签，但算法可以判断出上图存在两个簇(cluster)</p>
<p>这样的算法被称为簇类算法</p>
<h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>K-means即k均值算法</p>
<p>首先，在图中随机生成两点，这两点被称为聚类中心</p>
<p><img src="/images/机器学习入门课程笔记/87.png" alt></p>
<p>然后，算法会重复两件事情，先进行簇分配，然后进行中心的移动</p>
<p>簇分配是遍历所有样本点，根据它们距离那个中心更近，将它们划分给对应中心</p>
<p>中心移动指的是，根据上面划分好的两类点，把它们的中心移动到这一类点的均值位置</p>
<p>如果出现了一个没有任何一点归属于它的中心，最常见的办法是移除它。若必须保留，则移动时，随机给它一个新位置</p>
<p>算法的代价函数是所有点到其所在簇的距离均值，它可以调试我们的k均值算法是否在正确地工作</p>
<p>初始化时，可以随机挑选样本点作为初始簇位置，但这会导致你的k均值算法的结果取决于初始化的点。可能落入局部最优</p>
<p>简单的方法是多次执行k均值算法，使用不同的初始簇，任何挑选出最终结果的代价最小的那个</p>
<p>怎么选择聚类的数量呢？</p>
<p>肘部法则，即选择从2到n的簇数量，画出代价函数的值随着数量变化的图</p>
<p><img src="/images/机器学习入门课程笔记/88.png" alt></p>
<p>但实际上，往往我们无法找到清晰的肘部，像上面的右图。</p>
<p>那么我们不妨从后续问题的角度出发。如果是为衬衫的尺寸分类，我们只需要考虑分成3类好还是分成5类好，更多考虑其商业价值，然后直接去分类就好了</p>
<h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/01/15/Pygame——飞机大战/" rel="next" title="Pygame——飞机大战">
                <i class="fa fa-chevron-left"></i> Pygame——飞机大战
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/01/15/每天编程练习和打卡记录/" rel="prev" title="每天编程练习和打卡记录">
                每天编程练习和打卡记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jameci</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#机器学习的一些定义"><span class="nav-number">1.1.</span> <span class="nav-text">机器学习的一些定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#supervised-learning-监督学习"><span class="nav-number">1.2.</span> <span class="nav-text">supervised learning:监督学习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unsupervised-learning-无监督学习"><span class="nav-number">1.3.</span> <span class="nav-text">unsupervised learning:无监督学习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回归问题"><span class="nav-number">2.</span> <span class="nav-text">回归问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代价函数"><span class="nav-number">2.1.</span> <span class="nav-text">代价函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#梯度下降"><span class="nav-number">2.2.</span> <span class="nav-text">梯度下降</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性回归的梯度下降"><span class="nav-number">2.3.</span> <span class="nav-text">线性回归的梯度下降</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决小花的掉毛问题"><span class="nav-number">2.4.</span> <span class="nav-text">解决小花的掉毛问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读入-amp-读出数据集"><span class="nav-number">2.4.1.</span> <span class="nav-text">读入&amp;读出数据集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绘制图像"><span class="nav-number">2.4.2.</span> <span class="nav-text">绘制图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读入小花的掉毛数据并绘制散点图"><span class="nav-number">2.4.3.</span> <span class="nav-text">读入小花的掉毛数据并绘制散点图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析回归算法"><span class="nav-number">2.4.4.</span> <span class="nav-text">分析回归算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏导数"><span class="nav-number">2.4.5.</span> <span class="nav-text">偏导数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现和结果"><span class="nav-number">2.4.6.</span> <span class="nav-text">代码实现和结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习率和训练次数"><span class="nav-number">2.4.7.</span> <span class="nav-text">学习率和训练次数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多元回归"><span class="nav-number">3.</span> <span class="nav-text">多元回归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多元梯度下降法"><span class="nav-number">3.1.</span> <span class="nav-text">多元梯度下降法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特征缩放"><span class="nav-number">3.1.1.</span> <span class="nav-text">特征缩放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习率"><span class="nav-number">3.1.2.</span> <span class="nav-text">学习率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特征和多项式回归"><span class="nav-number">3.1.3.</span> <span class="nav-text">特征和多项式回归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正规方程"><span class="nav-number">3.2.</span> <span class="nav-text">正规方程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Octsve"><span class="nav-number">4.</span> <span class="nav-text">Octsve</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本操作"><span class="nav-number">4.1.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导入数据"><span class="nav-number">4.2.</span> <span class="nav-text">导入数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据的操作"><span class="nav-number">4.3.</span> <span class="nav-text">数据的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算"><span class="nav-number">4.4.</span> <span class="nav-text">运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可视化"><span class="nav-number">4.5.</span> <span class="nav-text">可视化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制语句"><span class="nav-number">4.6.</span> <span class="nav-text">控制语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">4.7.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向量化"><span class="nav-number">4.8.</span> <span class="nav-text">向量化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分类问题"><span class="nav-number">5.</span> <span class="nav-text">分类问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线性回归分类"><span class="nav-number">5.1.</span> <span class="nav-text">线性回归分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logistic回归"><span class="nav-number">5.2.</span> <span class="nav-text">Logistic回归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#决策边界-division-boundary"><span class="nav-number">5.2.1.</span> <span class="nav-text">决策边界(division boundary)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数拟合"><span class="nav-number">5.2.2.</span> <span class="nav-text">参数拟合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决礼物问题"><span class="nav-number">5.3.</span> <span class="nav-text">解决礼物问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python非向量化实现"><span class="nav-number">5.3.1.</span> <span class="nav-text">python非向量化实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级优化"><span class="nav-number">5.4.</span> <span class="nav-text">高级优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多分类问题"><span class="nav-number">5.5.</span> <span class="nav-text">多分类问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minst手写数据集分类"><span class="nav-number">5.6.</span> <span class="nav-text">Minst手写数据集分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#认识Minst手写数据集"><span class="nav-number">5.6.1.</span> <span class="nav-text">认识Minst手写数据集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手工解码idx格式"><span class="nav-number">5.6.2.</span> <span class="nav-text">手工解码idx格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一点数学推导"><span class="nav-number">5.6.3.</span> <span class="nav-text">一点数学推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python的张量操作"><span class="nav-number">5.6.4.</span> <span class="nav-text">python的张量操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">5.6.5.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#过拟合问题"><span class="nav-number">6.</span> <span class="nav-text">过拟合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加入惩罚"><span class="nav-number">6.1.</span> <span class="nav-text">加入惩罚</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则化"><span class="nav-number">6.2.</span> <span class="nav-text">正则化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#神经网络"><span class="nav-number">7.</span> <span class="nav-text">神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么学习神经网络"><span class="nav-number">7.1.</span> <span class="nav-text">为什么学习神经网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#神经网络的计算方法"><span class="nav-number">7.2.</span> <span class="nav-text">神经网络的计算方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用神经网络进行分类"><span class="nav-number">7.3.</span> <span class="nav-text">用神经网络进行分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反向传播算法"><span class="nav-number">7.4.</span> <span class="nav-text">反向传播算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#梯度检验"><span class="nav-number">7.5.</span> <span class="nav-text">梯度检验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机初始化"><span class="nav-number">7.6.</span> <span class="nav-text">随机初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的手写数据集分类"><span class="nav-number">7.7.</span> <span class="nav-text">简单的手写数据集分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#机器学习诊断法"><span class="nav-number">8.</span> <span class="nav-text">机器学习诊断法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#评估假设"><span class="nav-number">8.1.</span> <span class="nav-text">评估假设</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型选择"><span class="nav-number">8.2.</span> <span class="nav-text">模型选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#偏差和方差"><span class="nav-number">8.3.</span> <span class="nav-text">偏差和方差</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正则化-1"><span class="nav-number">8.3.1.</span> <span class="nav-text">正则化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习曲线"><span class="nav-number">8.3.2.</span> <span class="nav-text">学习曲线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接下来做什么"><span class="nav-number">8.4.</span> <span class="nav-text">接下来做什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#得出有效的模型"><span class="nav-number">9.</span> <span class="nav-text">得出有效的模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#偏斜类"><span class="nav-number">9.1.</span> <span class="nav-text">偏斜类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精确率和召回率的权衡"><span class="nav-number">9.2.</span> <span class="nav-text">精确率和召回率的权衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据问题"><span class="nav-number">9.3.</span> <span class="nav-text">数据问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#支持向量机SVM"><span class="nav-number">10.</span> <span class="nav-text">支持向量机SVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#大间距"><span class="nav-number">10.1.</span> <span class="nav-text">大间距</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核函数"><span class="nav-number">10.2.</span> <span class="nav-text">核函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#无监督学习"><span class="nav-number">11.</span> <span class="nav-text">无监督学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#K-means"><span class="nav-number">11.1.</span> <span class="nav-text">K-means</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#降维"><span class="nav-number">11.2.</span> <span class="nav-text">降维</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jameci</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
