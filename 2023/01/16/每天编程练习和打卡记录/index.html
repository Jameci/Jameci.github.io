<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="杂记,">










<meta name="description" content="2022.1.24今日天气：雪 善战者，制人而不制于人 ——孙子兵法  今日编程练习 Leetcode2045.到达目的地的第二短时间 描述 城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多">
<meta name="keywords" content="杂记">
<meta property="og:type" content="article">
<meta property="og:title" content="每天编程练习和打卡记录">
<meta property="og:url" content="http://yoursite.com/2023/01/16/每天编程练习和打卡记录/index.html">
<meta property="og:site_name" content="Jameci&#39;s Blog">
<meta property="og:description" content="2022.1.24今日天气：雪 善战者，制人而不制于人 ——孙子兵法  今日编程练习 Leetcode2045.到达目的地的第二短时间 描述 城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2023-01-17T10:36:06.068Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="每天编程练习和打卡记录">
<meta name="twitter:description" content="2022.1.24今日天气：雪 善战者，制人而不制于人 ——孙子兵法  今日编程练习 Leetcode2045.到达目的地的第二短时间 描述 城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2023/01/16/每天编程练习和打卡记录/">





  <title>每天编程练习和打卡记录 | Jameci's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jameci's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">天下雷行，物与无妄。先王以茂对时，育万物。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/01/16/每天编程练习和打卡记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jameci">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jameci's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">每天编程练习和打卡记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-01-16T02:22:10+08:00">
                2023-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂篇/" itemprop="url" rel="index">
                    <span itemprop="name">杂篇</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="2022-1-24"><a href="#2022-1-24" class="headerlink" title="2022.1.24"></a>2022.1.24</h1><p><em>今日天气：雪</em></p>
<p><em>善战者，制人而不制于人</em></p>
<p align="right"><em>——孙子兵法</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode2045.到达目的地的第二短时间</em></p>
<p><strong><em>描述</em></strong></p>
<p>城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。</p>
<p>每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。</p>
<p>第二小的值 是 严格大于 最小值的所有值中最小的值。</p>
<pre><code>例如，[2, 3, 4] 中第二小的值是 3 ，而 [2, 2, 4] 中第二小的值是 4 。
</code></pre><p>给你 n、edges、time 和 change ，返回从节点 1 到节点 n 需要的 第二短时间 。</p>
<p>注意：</p>
<pre><code>你可以 任意次 穿过任意顶点，包括 1 和 n 。
你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。
</code></pre><p><strong><em>思路</em></strong></p>
<p>这个题的点有两个，一个是怎么处理次短，一个是怎么计算时间</p>
<p>一开始只看出了第二点，然后以为是可以无限次通过某个点的简单的BFS，遂超时</p>
<p>看了题解才知道只需要找出最短路，然后处理一下即可</p>
<p>如何记录次短路呢？我们思考次短路是怎么产生的</p>
<p>由于所有路径都是双向的，所以我们只需要走最短路到达某点，然后再随便从该点向它相邻的另一个点走个来回就好了</p>
<p>所以，任何一个点的次短路长度不会超过最短路+2</p>
<p>如何判断有没有长度为最短路+1的次短路呢？</p>
<p>在BFS序中，我们把一个点的邻接点分为三种：</p>
<p>父节点，权值恰好比该点少1的节点</p>
<p>兄弟节点，权值等于该节点的点</p>
<p>子节点，权值为该节点减去1的点</p>
<p>那么，我们可以观察到，父节点如果有长度+1次短路，子节点也一定有。如果一个节点有兄弟，可以先走最短路到兄弟节点，然后一步走到该节点形成+1次短路</p>
<p>子节点对父节点的+1次短路无贡献</p>
<p>所以，我们在BFS时，进队列时确定最短路长度，出队列时，就可以确定次短路长度</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def cal(self, cur: int, time: int, change: int) -&gt; int:</span><br><span class="line">        if time % (2 * change) == 0:</span><br><span class="line">            return time * cur</span><br><span class="line">        else:</span><br><span class="line">            base = 0</span><br><span class="line">            wait = 0</span><br><span class="line">            for i in range(1, cur + 1):</span><br><span class="line">                if (i * time // change) % 2 == 1:</span><br><span class="line">                    base = i</span><br><span class="line">                    wait = change - i * time % change</span><br><span class="line">                    break</span><br><span class="line">            if base == 0:</span><br><span class="line">                return time * cur</span><br><span class="line">            else:</span><br><span class="line">                return time * cur + wait * ((cur - 1) // base)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -&gt; int:</span><br><span class="line">        d = defaultdict(list)</span><br><span class="line">        v = []</span><br><span class="line">        sv = []</span><br><span class="line">        for edge in edges:</span><br><span class="line">            d[edge[0]].append(edge[1])</span><br><span class="line">            d[edge[1]].append(edge[0])</span><br><span class="line">        </span><br><span class="line">        for i in range(n + 1):</span><br><span class="line">            v.append(-1)</span><br><span class="line">            sv.append(-1)</span><br><span class="line"></span><br><span class="line">        q = Queue()</span><br><span class="line">        q.put([1, 0])</span><br><span class="line">        v[1] = 0</span><br><span class="line">        while not q.empty():</span><br><span class="line">            cur = q.get()</span><br><span class="line">            sv[cur[0]] = v[cur[0]] + 2</span><br><span class="line">            for i in d[cur[0]]:</span><br><span class="line">                if v[i] == -1:</span><br><span class="line">                    q.put([i, cur[1] + 1])</span><br><span class="line">                    v[i] = cur[1] + 1</span><br><span class="line">                else:</span><br><span class="line">                    if v[i] == v[cur[0]]:</span><br><span class="line">                        sv[cur[0]] = v[cur[0]] + 1</span><br><span class="line">                    if v[i] + 1 == sv[i] and v[i] == v[cur[0]] - 1:</span><br><span class="line">                        sv[cur[0]] = v[cur[0]] + 1</span><br><span class="line"></span><br><span class="line">        return self.cal(sv[n], time, change)</span><br></pre></td></tr></table></figure>
<h1 id="2022-1-23"><a href="#2022-1-23" class="headerlink" title="2022.1.23"></a>2022.1.23</h1><p><em>今日天气：多云</em></p>
<p><em>人生不得长少年，莫惜床头沽酒钱</em></p>
<p align="right"><em>——蜀葵花</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode2034.股票价格波动</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。</p>
<p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。</p>
<p>请你设计一个算法，实现：</p>
<pre><code>更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。
找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。
找到当前记录里股票的 最高价格 。
找到当前记录里股票的 最低价格 。
</code></pre><p>请你实现 StockPrice 类：</p>
<pre><code>StockPrice() 初始化对象，当前无股票价格记录。
void update(int timestamp, int price) 在时间点 timestamp 更新股票价格为 price 。
int current() 返回股票 最新价格 。
int maximum() 返回股票 最高价格 。
int minimum() 返回股票 最低价格 。
</code></pre><p><strong><em>思路</em></strong></p>
<p>建立大顶小顶两个二叉堆</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">class StockPrice:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.maxkey = defaultdict(int)</span><br><span class="line">        self.maxheap = [[0, 0]]</span><br><span class="line">        self.minkey = defaultdict(int)</span><br><span class="line">        self.minheap = [[0, 0]]</span><br><span class="line">        self.curprice = [0, 0]</span><br><span class="line"></span><br><span class="line">    def maxdown(self, p: int) -&gt; None:</span><br><span class="line">        s = p * 2</span><br><span class="line">        while s &lt; len(self.maxheap):</span><br><span class="line">            if not (s + 1 &gt;= len(self.maxheap) or self.maxheap[s + 1][1] &lt; self.maxheap[s][1]):</span><br><span class="line">                s += 1</span><br><span class="line">            if self.maxheap[s][1] &gt; self.maxheap[p][1]:</span><br><span class="line">                t = self.maxheap[s]</span><br><span class="line">                self.maxheap[s] = self.maxheap[p]</span><br><span class="line">                self.maxheap[p] = t</span><br><span class="line">                t = self.maxkey[self.maxheap[p][0]]</span><br><span class="line">                self.maxkey[self.maxheap[p][0]] = self.maxkey[self.maxheap[s][0]]</span><br><span class="line">                self.maxkey[self.maxheap[s][0]] = t</span><br><span class="line">                p = s</span><br><span class="line">                s = p * 2</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    def maxup(self, p: int) -&gt; None:</span><br><span class="line">        s = p // 2</span><br><span class="line">        while s &gt; 0:</span><br><span class="line">            if self.maxheap[s][1] &lt; self.maxheap[p][1]:</span><br><span class="line">                t = self.maxheap[s]</span><br><span class="line">                self.maxheap[s] = self.maxheap[p]</span><br><span class="line">                self.maxheap[p] = t</span><br><span class="line">                t = self.maxkey[self.maxheap[p][0]]</span><br><span class="line">                self.maxkey[self.maxheap[p][0]] = self.maxkey[self.maxheap[s][0]]</span><br><span class="line">                self.maxkey[self.maxheap[s][0]] = t</span><br><span class="line">            p = s</span><br><span class="line">            s = p // 2</span><br><span class="line"></span><br><span class="line">    def mindown(self, p: int) -&gt; None:</span><br><span class="line">        s = p * 2</span><br><span class="line">        while s &lt; len(self.minheap):</span><br><span class="line">            if not (s + 1 &gt;= len(self.minheap) or self.minheap[s + 1][1] &gt; self.minheap[s][1]):</span><br><span class="line">                s += 1</span><br><span class="line">            if self.minheap[s][1] &lt; self.minheap[p][1]:</span><br><span class="line">                t = self.minheap[s]</span><br><span class="line">                self.minheap[s] = self.minheap[p]</span><br><span class="line">                self.minheap[p] = t</span><br><span class="line">                t = self.minkey[self.minheap[p][0]]</span><br><span class="line">                self.minkey[self.minheap[p][0]] = self.minkey[self.minheap[s][0]]</span><br><span class="line">                self.minkey[self.minheap[s][0]] = t</span><br><span class="line">                p = s</span><br><span class="line">                s = p * 2</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    def minup(self, p: int) -&gt; None:</span><br><span class="line">        s = p // 2</span><br><span class="line">        print(p, s)</span><br><span class="line">        while s &gt; 0:</span><br><span class="line">            if self.minheap[s][1] &gt; self.minheap[p][1]:</span><br><span class="line">                t = self.minheap[s]</span><br><span class="line">                self.minheap[s] = self.minheap[p]</span><br><span class="line">                self.minheap[p] = t</span><br><span class="line">                t = self.minkey[self.minheap[p][0]]</span><br><span class="line">                self.minkey[self.minheap[p][0]] = self.minkey[self.minheap[s][0]]</span><br><span class="line">                self.minkey[self.minheap[s][0]] = t</span><br><span class="line">            p = s</span><br><span class="line">            s = p // 2</span><br><span class="line"></span><br><span class="line">    def remove(self, timestamp: int) -&gt; None:</span><br><span class="line">        p = self.maxkey[timestamp]</span><br><span class="line">        del self.maxkey[timestamp]</span><br><span class="line">        if p != len(self.maxheap) - 1:</span><br><span class="line">            self.maxheap[p] = self.maxheap[len(self.maxheap) - 1]</span><br><span class="line">            self.maxkey[self.maxheap[p][0]] = p</span><br><span class="line">            del self.maxheap[-1]</span><br><span class="line">            self.maxdown(p)</span><br><span class="line">            self.maxup(p)</span><br><span class="line">        else:</span><br><span class="line">            del self.maxheap[-1]</span><br><span class="line"></span><br><span class="line">        p = self.minkey[timestamp]</span><br><span class="line">        del self.minkey[timestamp]</span><br><span class="line">        if p != len(self.minheap) - 1:</span><br><span class="line">            self.minheap[p] = self.minheap[len(self.minheap) - 1]</span><br><span class="line">            self.minkey[self.minheap[p][0]] = p</span><br><span class="line">            del self.minheap[-1]</span><br><span class="line">            self.mindown(p)</span><br><span class="line">            self.minup(p)</span><br><span class="line">        else:</span><br><span class="line">            del self.minheap[-1]</span><br><span class="line"></span><br><span class="line">    def insert(self, timestamp: int, price: int) -&gt; None:</span><br><span class="line">        self.maxheap.append([timestamp, price])</span><br><span class="line">        self.maxkey[timestamp] = len(self.maxheap) - 1</span><br><span class="line">        self.maxup(len(self.maxheap) - 1)</span><br><span class="line">        self.minheap.append([timestamp, price])</span><br><span class="line">        self.minkey[timestamp] = len(self.minheap) - 1</span><br><span class="line">        self.minup(len(self.minheap) - 1)</span><br><span class="line"></span><br><span class="line">    def update(self, timestamp: int, price: int) -&gt; None:</span><br><span class="line">        if timestamp &gt;= self.curprice[0]:</span><br><span class="line">            self.curprice[0] = timestamp</span><br><span class="line">            self.curprice[1] = price</span><br><span class="line">        </span><br><span class="line">        if self.maxkey[timestamp] != 0:</span><br><span class="line">            self.remove(timestamp)</span><br><span class="line">        self.insert(timestamp, price)</span><br><span class="line"></span><br><span class="line">        #print(self.maxheap)</span><br><span class="line">        #print(self.minheap)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    def current(self) -&gt; int:</span><br><span class="line">        return self.curprice[1]</span><br><span class="line"></span><br><span class="line">    def maximum(self) -&gt; int:</span><br><span class="line">        return self.maxheap[1][1]</span><br><span class="line"></span><br><span class="line">    def minimum(self) -&gt; int:</span><br><span class="line">        return self.minheap[1][1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Your StockPrice object will be instantiated and called as such:</span><br><span class="line"># obj = StockPrice()</span><br><span class="line"># obj.update(timestamp,price)</span><br><span class="line"># param_2 = obj.current()</span><br><span class="line"># param_3 = obj.maximum()</span><br><span class="line"># param_4 = obj.minimum()</span><br></pre></td></tr></table></figure>
<h1 id="2022-1-22"><a href="#2022-1-22" class="headerlink" title="2022.1.22"></a>2022.1.22</h1><p><em>今日天气：晴</em></p>
<p><em>无论面对怎样的困难，比克服困难的技能更重要的，是克服困难的动机。只要内心的火焰没有熄灭，无论寒风再凛冽，活着也是一件温暖的事情</em></p>
<p><strong>今日编程练习</strong></p>
<p><em>Leetcode1332.删除回文子序列</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一个字符串 s，它仅由字母 ‘a’ 和 ‘b’ 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。</p>
<p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p>
<p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p>
<p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</p>
<p><strong><em>思路</em></strong></p>
<p>所有的a构成回文子序列，所有的b也构成回文子序列，因此最差情况下也可以先删除a再删除b来得到</p>
<p>所以，如果原字符串是回文字符串，答案是1，否则是2</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removePalindromeSub(self, s: str) -&gt; int:</span><br><span class="line">        for i in range(len(s) // 2):</span><br><span class="line">            if s[i] != s[len(s) - 1 - i]:</span><br><span class="line">                return 2</span><br><span class="line">        return 1</span><br></pre></td></tr></table></figure>
<h1 id="2021-1-21"><a href="#2021-1-21" class="headerlink" title="2021.1.21"></a>2021.1.21</h1><p><em>今日天气：雪</em></p>
<p><em>天下雷行，物与无妄。先王以茂对时，育万物</em></p>
<p align="right"><em>——易经</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode1345.跳跃游戏 IV</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。</p>
<p>每一步，你可以从下标 i 跳到下标：</p>
<pre><code>i + 1 满足：i + 1 &lt; arr.length
i - 1 满足：i - 1 &gt;= 0
j 满足：arr[i] == arr[j] 且 i != j
</code></pre><p>请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
<p><strong><em>思路</em></strong></p>
<p>从起点开始的BFS</p>
<p>但为了准备这个BFS，我们需要建立一个邻接表，之后我注意到，当某个邻接表的一个元素被遍历到的时候，整个邻接表的其它元素接着就会被遍历到，因此，我又设置了一个标记数组来表示某个邻接表是否被遍历了</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def minJumps(self, arr: List[int]) -&gt; int:</span><br><span class="line">        d = defaultdict(list)</span><br><span class="line">        d2 = defaultdict(int)</span><br><span class="line">        v = []</span><br><span class="line">        p = []</span><br><span class="line">        for i in range(len(arr)):</span><br><span class="line">            d[arr[i]].append(i)</span><br><span class="line">            d2[arr[i]] = 0</span><br><span class="line">            v.append(False)</span><br><span class="line">            p.append(0x7fffffff)</span><br><span class="line"></span><br><span class="line">        cur = 0</span><br><span class="line">        p[0] = 0</span><br><span class="line">        q = Queue()</span><br><span class="line">        q.put(0)</span><br><span class="line">        v[0] = True</span><br><span class="line">        while q.qsize() != 0:</span><br><span class="line">            cur = q.get()</span><br><span class="line">            if cur &gt; 0 and not v[cur - 1]:</span><br><span class="line">                p[cur - 1] = p[cur] + 1</span><br><span class="line">                q.put(cur - 1)</span><br><span class="line">                v[cur - 1] = True</span><br><span class="line">            if cur &lt; len(arr) - 1 and not v[cur + 1]:</span><br><span class="line">                p[cur + 1] = p[cur] + 1</span><br><span class="line">                q.put(cur + 1)</span><br><span class="line">                v[cur + 1] = True</span><br><span class="line">            if d2[arr[cur]] == 0:</span><br><span class="line">                for i in d[arr[cur]]:</span><br><span class="line">                    if v[i]:</span><br><span class="line">                        continue</span><br><span class="line">                    p[i] = p[cur] + 1</span><br><span class="line">                    q.put(i)</span><br><span class="line">                    v[i] = True</span><br><span class="line">                d2[arr[cur]] = 1</span><br><span class="line"></span><br><span class="line">        return p[len(arr) - 1]</span><br></pre></td></tr></table></figure>
<h1 id="2022-1-20"><a href="#2022-1-20" class="headerlink" title="2022.1.20"></a>2022.1.20</h1><p><em>今日天气：雪</em></p>
<p><em>孤独如荒漠，理性如孤岛</em></p>
<p><strong>今日编程练习</strong></p>
<p><em>Leetcode2029.石子游戏 IX</em></p>
<p><strong><em>描述</em></strong></p>
<p>Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。</p>
<p>Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。</p>
<pre><code>如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
</code></pre><p>假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。</p>
<p><strong><em>思路</em></strong></p>
<p>先考虑问题的初始状态，此时拿走的总价值是0</p>
<p>那么Alice第一次该怎么拿呢？显然她不能拿走3的倍数，不然一下就输了</p>
<p>所以Alice的策略只有两种：拿走模3余1的数和拿走模3余2的数</p>
<p>假设Alice拿走了模3余1的数，总价值现在模3余1，那么Bob此时又该怎么选呢？</p>
<p>显然Bob只能也选择模3余1的数，把总价值变成模3余2，或者Bob选择3的倍数，总价值还是模3余1</p>
<p>我们先不考虑3的倍数，因为3的倍数拿走之后，总价值不会变化，实际上它起到了仅仅是一个“空过”的作用</p>
<p><strong><em>没有3的情况</em></strong></p>
<p>假设只有模3余1的数（以下简称为1）N1个，模3余2的数（以下简称为2）N2个，那么，Alice有没有必胜策略呢？</p>
<p>简单推导一下发现，如果Alice拿了1，Bob也只能拿1，然后Alice只能拿2，Bob又只能拿1，如此循环，如果1先没了，Alice胜，2先没了，Bob胜</p>
<p>简单来说，游戏过程变成了：</p>
<p>1.Alice拿走了X（X表示1或2）</p>
<p>2.Bob拿走了X，接着Alice拿走了Y（Y = 3 - X）</p>
<p>3.重复2，直到某个人无法拿到他想要的石头</p>
<p>上述游戏过程中，Alice拿走了1个X，n个Y，Bob拿走了n个X，然后，X没有了</p>
<p>那么，Alice的必胜策略其实很简单了，她只需要保证X的数量首先大于1，并且小于等于Y即可</p>
<p>所以在这种情况下，只要1和2的数量大于0，Alice必胜</p>
<p>如果至少有一种的数量小于0，Bob必胜</p>
<p><strong><em>有3的情况</em></strong></p>
<p>假设有3的倍数（简称为3），该怎么办呢？</p>
<p>上面说了，3起到一个空过的作用，当某人发现自己情况不利时，可以选3的倍数，空过，让对方面临自己的局面</p>
<p>但事情没有这么简单，如果Bob发现Alice给他设局，Bob选择空过的话，Alice也可以选择空过，让Bob的空过作废</p>
<p>所以，当3的次数是偶数次的时候，对Alice来说局势和没有3的情况一致</p>
<p>如果是奇数次呢？</p>
<p>这意味着Bob空过之后，Alice将没有反制他的机会。对于Alice来说，此时需要反其道而行之，选择数目较多的，等待Bob空过来使得局面反转</p>
<p>要是Bob不反转怎么办？那Alice就要主动帮他反转</p>
<p>此时，一局游戏应该是这样的：</p>
<p>1.Alice拿走了X</p>
<p>2.Bob拿走了X，Alice拿走了3</p>
<p>3.Bob拿走了Y，Alice拿走了X</p>
<p>4.重复3，直到某人拿不到他想要的石头</p>
<p>发现Alice拿走了n+1个X，Bob拿走了n个Y，1个X</p>
<p>所以，需要X的数量严格大于Y+2才行，否则，无论Alice怎么空过，等待她的只有死局</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def stoneGameIX(self, stones: List[int]) -&gt; bool:</span><br><span class="line">        temp = [0, 0, 0]</span><br><span class="line">        for i in stones:</span><br><span class="line">            temp[i % 3] += 1</span><br><span class="line">        if temp[0] % 2 == 1:</span><br><span class="line">            return abs(temp[1] - temp[2]) &gt; 2</span><br><span class="line">        else:</span><br><span class="line">            return not(temp[1] == 0 or temp[2] == 0)</span><br></pre></td></tr></table></figure>
<h1 id="2022-1-19"><a href="#2022-1-19" class="headerlink" title="2022.1.19"></a>2022.1.19</h1><p><em>今日天气：阴转晴</em></p>
<p><em>楚伐随，随曰：“我无罪”，楚曰：“我蛮夷也”</em></p>
<p align="right"><em>——史记·楚世家</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode219.存在重复元素 II</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。</p>
<p><strong><em>思路</em></strong></p>
<p>字典题，只不过需要搞一个过期处理</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:</span><br><span class="line">        d = defaultdict(int)</span><br><span class="line">        </span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if d[nums[i]] &gt; 0:</span><br><span class="line">                return True</span><br><span class="line">            d[nums[i]] += 1</span><br><span class="line">            if i &gt;= k:</span><br><span class="line">                d[nums[i - k]] -= 1</span><br><span class="line">        </span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h1 id="2021-11-3"><a href="#2021-11-3" class="headerlink" title="2021.11.3"></a>2021.11.3</h1><p><em>今日天气：晴</em></p>
<p><em>“你的面前有一面墙，向上无限高，向下无限深，向左无限长，向右也无限长，这面墙是什么？”</em></p>
<p><em>“死亡”</em></p>
<p align="right"><em>——三体2·黑暗森林</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode367.有效的完全平方数</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定整数num，不用内置函数判断它是否是完全平方数。</p>
<p><strong><em>思路</em></strong></p>
<p>根据num的范围二分即可。标准答案用了牛顿迭代法……</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPerfectSquare(self, num: int) -&gt; bool:</span><br><span class="line">        low = 0</span><br><span class="line">        high = 1 &lt;&lt; 16</span><br><span class="line">        while low &lt; high:</span><br><span class="line">            mid = (low + high) &gt;&gt; 1</span><br><span class="line">            temp = mid * mid</span><br><span class="line">            if num == temp:</span><br><span class="line">                return True</span><br><span class="line">            elif num &lt; temp:</span><br><span class="line">                high = mid</span><br><span class="line">            else:</span><br><span class="line">                low = mid + 1</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h1 id="2021-11-1"><a href="#2021-11-1" class="headerlink" title="2021.11.1"></a>2021.11.1</h1><p><em>今日天气：晴</em></p>
<p><em>并非是我选择了这样的一生，而是这一生选择了我</em></p>
<p align="right"><em>——刺客信条</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode575.分糖果</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<p><strong><em>思路</em></strong></p>
<p>每种都给妹妹一块即可，最多给她m/2种</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def distributeCandies(self, candyType: List[int]) -&gt; int:</span><br><span class="line">        max_l = len(candyType) // 2</span><br><span class="line">        max_t = 0</span><br><span class="line">        d = defaultdict(int)</span><br><span class="line">        for i in candyType:</span><br><span class="line">            if d[i] == 0:</span><br><span class="line">                max_t += 1</span><br><span class="line">            d[i] += 1</span><br><span class="line">        return min(max_l, max_t)</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-31"><a href="#2021-10-31" class="headerlink" title="2021.10.31"></a>2021.10.31</h1><p><em>今日天气：阴</em></p>
<p><em>他知道要想逃避现实，最好的方式就是深深介入现实之中。</em></p>
<p align="right"><em>——三体·黑暗森林</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode500.键盘行</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。</p>
<p>美式键盘 中：</p>
<pre><code>第一行由字符 &quot;qwertyuiop&quot; 组成。
第二行由字符 &quot;asdfghjkl&quot; 组成。
第三行由字符 &quot;zxcvbnm&quot; 组成。
</code></pre><p><strong><em>思路</em></strong></p>
<p>简简单单一个数组</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findWords(self, words: List[str]) -&gt; List[str]:</span><br><span class="line">        temp = [</span><br><span class="line">            2, 3, 3, 2, 1, 2, 2, 2, 1, 2, 2, 2, 3, 3,</span><br><span class="line">            1, 1, 1, 1, 2, 1, 1, 3, 1, 3, 1, 3</span><br><span class="line">        ]</span><br><span class="line">        ret = []</span><br><span class="line">        for s in words:</span><br><span class="line">            flag = temp[ord(s[0].lower()) - ord(&apos;a&apos;)]</span><br><span class="line">            for i in range(1, len(s)):</span><br><span class="line">                if flag != temp[ord(s[i].lower()) - ord(&apos;a&apos;)]:</span><br><span class="line">                    flag = 0</span><br><span class="line">                    break</span><br><span class="line">            if flag != 0:</span><br><span class="line">                ret.append(s)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-30"><a href="#2021-10-30" class="headerlink" title="2021.10.30"></a>2021.10.30</h1><p><em>今日天气：晴</em></p>
<p><em>她缓慢地点点头：“人生苦短啊。”，她最后这句话出动了他心灵深处的什么东西，他那被冬风吹得发干的双眼突然有些湿润：“是啊，人生苦短。”。</em></p>
<p align="right"><em>——思想者</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode260.只出现一次的数字Ⅲ</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p>
<p><strong><em>思路</em></strong></p>
<p>异或+lowbit，有两个数不一样，那么所有数异或的结果等于这两个数的异或结果</p>
<p>使用lowbit取出最低位1，说明在这一位，数a是1，数b是0</p>
<p>再把所有在该位是1的数异或起来，结果就是数a</p>
<p>同理得数b</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        x = 0</span><br><span class="line">        for i in nums:</span><br><span class="line">            x ^= i</span><br><span class="line">        x &amp;= -x</span><br><span class="line">        a = 0</span><br><span class="line">        b = 0</span><br><span class="line">        for i in nums:</span><br><span class="line">            if i &amp; x == 0:</span><br><span class="line">                a ^= i</span><br><span class="line">            else:</span><br><span class="line">                b ^= i</span><br><span class="line">        return [a, b]</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-28"><a href="#2021-10-28" class="headerlink" title="2021.10.28"></a>2021.10.28</h1><p><em>今日天气：晴</em></p>
<p><em>真正的智者不会向你指明真相，而是教导你去发现真相。</em></p>
<p align="right"><em>——刺客信条</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode869.重新排序得到2的幂</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>
<p>如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。</p>
<p><strong><em>思路</em></strong></p>
<p>记录2的幂中各数字出现的次数</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    base = [1, 10, 100, 1000, 10000, 100000, 1000000,10000000, 100000000, 1000000000, 10000000000]</span><br><span class="line">    </span><br><span class="line">    def encode(self, n: int) -&gt; int:</span><br><span class="line">        ret = 0</span><br><span class="line">        while n &gt; 0:</span><br><span class="line">            cur = n % 10</span><br><span class="line">            ret += self.base[cur]</span><br><span class="line">            n //= 10</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def reorderedPowerOf2(self, n: int) -&gt; bool:</span><br><span class="line">        if n == 0:</span><br><span class="line">            return False</span><br><span class="line">        d = defaultdict(int)</span><br><span class="line">        t = 1</span><br><span class="line">        for i in range(32):</span><br><span class="line">            d[self.encode(t)] = 1</span><br><span class="line">            t &lt;&lt;= 1</span><br><span class="line">        return d[self.encode(n)] == 1</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-27"><a href="#2021-10-27" class="headerlink" title="2021.10.27"></a>2021.10.27</h1><p><em>今日天气：晴</em></p>
<p><em>不知所措，才是人生。</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode301.删除无效的括号</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按 任意顺序 返回。</p>
<p><strong><em>思路</em></strong></p>
<p>爆搜</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def initation(self, s: str) -&gt; List[str]:</span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        flag1 = -1</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if flag1 != -1:</span><br><span class="line">                break</span><br><span class="line">            if s[i] == &apos;(&apos;:</span><br><span class="line">                flag1 = i</span><br><span class="line"></span><br><span class="line">        flag2 = 1</span><br><span class="line">        for i in range(-1, -len(s) - 1, -1):</span><br><span class="line">            if flag2 != 1:</span><br><span class="line">                break</span><br><span class="line">            if s[i] == &apos;)&apos;:</span><br><span class="line">                flag2 = i</span><br><span class="line"></span><br><span class="line">        if flag1 == -1:</span><br><span class="line">            for i in s:</span><br><span class="line">                if i != &apos;)&apos;:</span><br><span class="line">                    ret.append(i)</span><br><span class="line">        elif flag2 == 1:</span><br><span class="line">            for i in s:</span><br><span class="line">                if i != &apos;(&apos;:</span><br><span class="line">                    ret.append(i)</span><br><span class="line">        else:</span><br><span class="line">            flag2 += len(s)</span><br><span class="line"></span><br><span class="line">            if flag1 &gt; flag2:</span><br><span class="line">                for i in s:</span><br><span class="line">                    if i != &apos;(&apos; and i != &apos;)&apos;:</span><br><span class="line">                        ret.append(i)</span><br><span class="line">            else:</span><br><span class="line">                for i in range(flag1):</span><br><span class="line">                    if s[i] != &apos;)&apos;:</span><br><span class="line">                        ret.append(s[i])</span><br><span class="line">        </span><br><span class="line">                ret += s[flag1 : flag2]</span><br><span class="line"></span><br><span class="line">                for i in range(flag2, len(s)):</span><br><span class="line">                    if s[i] != &apos;(&apos;:</span><br><span class="line">                        ret.append(s[i])</span><br><span class="line"></span><br><span class="line">        return ret</span><br><span class="line">    </span><br><span class="line">    def calnum(self, s: List[str]) -&gt; int:</span><br><span class="line">        t = 0</span><br><span class="line">        num = 0</span><br><span class="line">        for i in s:</span><br><span class="line">            if i == &apos;)&apos;:</span><br><span class="line">                t -= 1</span><br><span class="line">                if t &lt; 0:</span><br><span class="line">                    num -= t</span><br><span class="line">                    t = 0</span><br><span class="line">            elif i == &apos;(&apos;:</span><br><span class="line">                t += 1</span><br><span class="line"></span><br><span class="line">        if t &lt; 0:</span><br><span class="line">            num -= t</span><br><span class="line">        else:</span><br><span class="line">            num += t</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">    def decode(self, s: List[str]) -&gt; str:</span><br><span class="line">        ret = &quot;&quot;</span><br><span class="line">        for i in s:</span><br><span class="line">            ret += i</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def dfs(self, ret: List[str], s: List[str], num: int, pos: int):</span><br><span class="line">        if num &lt; 0:</span><br><span class="line">            return</span><br><span class="line">        if pos + num &gt; len(s):</span><br><span class="line">            return</span><br><span class="line">        if num == 0:</span><br><span class="line">            if self.calnum(s) == 0:</span><br><span class="line">                ret.append(self.decode(s))</span><br><span class="line">        else:</span><br><span class="line">            if s[pos] == &apos;(&apos;:</span><br><span class="line">                end = pos</span><br><span class="line">                while end &lt; len(s) and s[end] == &apos;(&apos;:</span><br><span class="line">                    end += 1</span><br><span class="line">                self.dfs(ret, s, num, end)</span><br><span class="line">                for i in range(end - pos):</span><br><span class="line">                    del s[pos]</span><br><span class="line">                    self.dfs(ret, s, num - i - 1, end - i - 1)</span><br><span class="line">                for i in range(end - pos):</span><br><span class="line">                    s.insert(pos, &apos;(&apos;)      </span><br><span class="line">            elif s[pos] == &apos;)&apos;:</span><br><span class="line">                end = pos</span><br><span class="line">                while end &lt; len(s) and s[end] == &apos;)&apos;:</span><br><span class="line">                    end += 1</span><br><span class="line">                self.dfs(ret, s, num, end)</span><br><span class="line">                for i in range(end - pos):</span><br><span class="line">                    del s[pos]</span><br><span class="line">                    self.dfs(ret, s, num - i - 1, end - i - 1)</span><br><span class="line">                for i in range(end - pos):</span><br><span class="line">                    s.insert(pos, &apos;)&apos;)          </span><br><span class="line">            else:</span><br><span class="line">                self.dfs(ret, s, num, pos + 1)</span><br><span class="line"></span><br><span class="line">    def removeInvalidParentheses(self, s: str) -&gt; List[str]:</span><br><span class="line">        ns = self.initation(s)</span><br><span class="line">        print(self.decode(ns))</span><br><span class="line">        num = self.calnum(ns)</span><br><span class="line">        print(num)</span><br><span class="line">        ret = []</span><br><span class="line">        self.dfs(ret, ns, num, 0)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-26"><a href="#2021-10-26" class="headerlink" title="2021.10.26"></a>2021.10.26</h1><p><em>今日天气：晴</em></p>
<p><em>遇到迷茫时，任何人都会变得软弱。 一旦坚信自己可以帮到别人，他们就会变得很强大。</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode496.下一个更大元素 I</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p><strong><em>思路</em></strong></p>
<p>维护单调栈+一个字典</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:</span><br><span class="line">        d = defaultdict(int)</span><br><span class="line">        s = [nums2[0]]</span><br><span class="line">        for i in range(1, len(nums2)):</span><br><span class="line">            while len(s) &gt; 0 and nums2[i] &gt; s[-1]:</span><br><span class="line">                d[s[-1]] = nums2[i]</span><br><span class="line">                del s[-1]</span><br><span class="line">            s.append(nums2[i])</span><br><span class="line">        </span><br><span class="line">        for i in s:</span><br><span class="line">            d[i] = -1</span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        for i in nums1:</span><br><span class="line">            ret.append(d[i])</span><br><span class="line">        </span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-25"><a href="#2021-10-25" class="headerlink" title="2021.10.25"></a>2021.10.25</h1><p><em>今日天气：晴</em></p>
<p><em>一个人的死，对于这个世界来说不过是多了一座坟墓，但对于相依为命的人来说、却是整个世界都被坟墓掩埋</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode240.搜索二维矩阵Ⅱ</em></p>
<p><strong><em>描述</em></strong></p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<pre><code>每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
</code></pre><p><strong><em>思路</em></strong></p>
<p>z字型查找，先从矩阵的左上角或者右下角查找，以左下角为例：</p>
<p>若target比当前元素大，说明比当前元素小的全部忽略，则当前元素右移一格</p>
<p>反之，左移一格，总复杂度O(m + n)</p>
<p>我一直在找复杂度O(logm + logn)的双重二分，写了3小时还是不行</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:</span><br><span class="line">        n = len(matrix)</span><br><span class="line">        m = len(matrix[0])</span><br><span class="line">        i = n - 1</span><br><span class="line">        j = 0</span><br><span class="line">        </span><br><span class="line">        while i &gt;= 0 and j &lt; m:</span><br><span class="line">            if matrix[i][j] &lt; target:</span><br><span class="line">                j += 1</span><br><span class="line">            elif matrix[i][j] &gt; target:</span><br><span class="line">                i -= 1</span><br><span class="line">            else:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-24"><a href="#2021-10-24" class="headerlink" title="2021.10.24"></a>2021.10.24</h1><p><em>今日天气：晴</em></p>
<p><em>因为孤独比受伤还要痛苦</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode638.大礼包</em></p>
<p><strong><em>描述</em></strong></p>
<p>在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>
<p>给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。</p>
<p>还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。</p>
<p>返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p>
<p><strong><em>思路</em></strong></p>
<p>dp，不过实现得太笨重了点</p>
<p><strong><em>C++</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int shoppingOffers(vector&lt;int&gt;&amp; price, vector&lt;vector&lt;int&gt;&gt;&amp; special, vector&lt;int&gt;&amp; needs) &#123;</span><br><span class="line">        int n = 6 - needs.size();</span><br><span class="line">        if(n)&#123;</span><br><span class="line">            for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">                price.push_back(0);</span><br><span class="line">                needs.push_back(0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int i = 0; i &lt; special.size(); ++i)&#123;</span><br><span class="line">                int temp = special[i].size() - 1;</span><br><span class="line">                for(int j = 0; j &lt; n; ++j)&#123;</span><br><span class="line">                    special[i].push_back(0);</span><br><span class="line">                &#125;</span><br><span class="line">                swap(special[i][temp], special[i][6]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int d[11][11][11][11][11][11];</span><br><span class="line">        memset(d, 0x7f, sizeof(d));</span><br><span class="line">        d[0][0][0][0][0][0] = 0;</span><br><span class="line">        for(int i0 = 0; i0 &lt;= needs[0]; ++i0)&#123;</span><br><span class="line">            for(int i1 = 0; i1 &lt;= needs[1]; ++i1)&#123;</span><br><span class="line">                for(int i2 = 0; i2 &lt;= needs[2]; ++i2)&#123;</span><br><span class="line">                    for(int i3 = 0; i3 &lt;= needs[3]; ++i3)&#123;</span><br><span class="line">                        for(int i4 = 0; i4 &lt;= needs[4]; ++i4)&#123;</span><br><span class="line">                            for(int i5 = 0; i5 &lt;= needs[5]; ++i5)&#123;</span><br><span class="line">                                int *cur = &amp;d[i0][i1][i2][i3][i4][i5];</span><br><span class="line">                                if(i0) *cur = min(*cur, d[i0 - 1][i1][i2][i3][i4][i5] + price[0]);</span><br><span class="line">                                if(i1) *cur = min(*cur, d[i0][i1 - 1][i2][i3][i4][i5] + price[1]);</span><br><span class="line">                                if(i2) *cur = min(*cur, d[i0][i1][i2 - 1][i3][i4][i5] + price[2]);   </span><br><span class="line">                                if(i3) *cur = min(*cur, d[i0][i1][i2][i3 - 1][i4][i5] + price[3]);</span><br><span class="line">                                if(i4) *cur = min(*cur, d[i0][i1][i2][i3][i4 - 1][i5] + price[4]);</span><br><span class="line">                                if(i5) *cur = min(*cur, d[i0][i1][i2][i3][i4][i5 - 1] + price[5]);</span><br><span class="line">                                for(int i = 0; i &lt; special.size(); ++i)&#123;</span><br><span class="line">                                    if(i0 &lt; special[i][0]) continue;</span><br><span class="line">                                    if(i1 &lt; special[i][1]) continue;</span><br><span class="line">                                    if(i2 &lt; special[i][2]) continue;</span><br><span class="line">                                    if(i3 &lt; special[i][3]) continue;</span><br><span class="line">                                    if(i4 &lt; special[i][4]) continue;</span><br><span class="line">                                    if(i5 &lt; special[i][5]) continue;</span><br><span class="line">                                    *cur = min(*cur, d[i0 - special[i][0]][i1 - special[i][1]][i2 - special[i][2]][i3 - special[i][3]][i4 - special[i][4]][i5 - special[i][5]] + special[i][6]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return d[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-23"><a href="#2021-10-23" class="headerlink" title="2021.10.23"></a>2021.10.23</h1><p><em>今日天气：晴</em></p>
<p><em>即使相处的时间不多，但真挚的友情是不在意时间长短的</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode492.构造矩形</em></p>
<p><strong><em>描述</em></strong></p>
<p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p>
<ol>
<li><p>你设计的矩形页面必须等于给定的目标面积。</p>
</li>
<li><p>宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</p>
</li>
<li><p>长度 L 和宽度 W 之间的差距应当尽可能小。</p>
</li>
</ol>
<p>你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p>
<p><strong><em>思路</em></strong></p>
<p>分解因数</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def constructRectangle(self, area: int) -&gt; List[int]:</span><br><span class="line">        ret = [area]</span><br><span class="line">        i = 2</span><br><span class="line">        while i * i &lt;= area:</span><br><span class="line">            if area % i == 0:</span><br><span class="line">                ret[0] = area // i </span><br><span class="line">            i += 1</span><br><span class="line">        ret.append(area // ret[0])</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-21"><a href="#2021-10-21" class="headerlink" title="2021.10.21"></a>2021.10.21</h1><p><em>今日天气：晴</em></p>
<p><em>人的梦想，是不会终结的！</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode66.加一</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong><em>思路</em></strong></p>
<p>模拟即可，注意999之类的数</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        flag = True</span><br><span class="line">        for i in range(-1, -len(digits) - 1, -1):</span><br><span class="line">            if digits[i] == 9:</span><br><span class="line">                digits[i] = 0</span><br><span class="line">            else:</span><br><span class="line">                digits[i] += 1</span><br><span class="line">                flag = False</span><br><span class="line">                break</span><br><span class="line">        if flag:</span><br><span class="line">            digits.insert(0, 1)</span><br><span class="line">        return digits</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-20"><a href="#2021-10-20" class="headerlink" title="2021.10.20"></a>2021.10.20</h1><p><em>今日天气：晴</em></p>
<p><em>永无止境便是终结！</em></p>
<p align="right"><em>——JoJo的奇妙冒险·黄金之风</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode453.最小操作次数使数组元素相等</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。</p>
<p><strong><em>思路</em></strong></p>
<p>每次使n - 1个元素加1，相当于每次让一个元素减1，肯定让所有元素减1等于最小的那个</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minMoves(self, nums: List[int]) -&gt; int:</span><br><span class="line">        ret = 0</span><br><span class="line">        mn = 1000000000</span><br><span class="line">        for i in nums:</span><br><span class="line">            ret += i</span><br><span class="line">            if i &lt; mn:</span><br><span class="line">                mn = i</span><br><span class="line">        return ret - mn * len(nums)</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-18"><a href="#2021-10-18" class="headerlink" title="2021.10.18"></a>2021.10.18</h1><p><em>今日天气：晴</em></p>
<p><em>我终将逝去，而你，即将加冕为王！</em></p>
<p align="right"><em>——魔兽争霸·巫妖王之怒</em></p>

<p><strong><em>今日编程练习</em></strong></p>
<p><em>Leetcode476.数字的补数</em></p>
<p><strong>描述</strong></p>
<p>对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。</p>
<pre><code>例如，整数 5 的二进制表示是 &quot;101&quot; ，取反后得到 &quot;010&quot; ，再转回十进制表示得到补数 2 。
</code></pre><p>给你一个整数 num ，输出它的补数。</p>
<p><strong>思路</strong></p>
<p>直接找到恰恰大于num的二进制整数，然后相减即可</p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findComplement(self, num: int) -&gt; int:</span><br><span class="line">        base = 1</span><br><span class="line">        while base &lt;= num:</span><br><span class="line">            base &lt;&lt;= 1</span><br><span class="line">        return base - num - 1</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-17"><a href="#2021-10-17" class="headerlink" title="2021.10.17"></a>2021.10.17</h1><p><em>今日天气：晴</em></p>
<p><em>不要为别人给你的爱加上理由！</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode230.二叉搜索树中第K小的元素</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p><strong><em>思路</em></strong></p>
<p>中序遍历</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def find(self, root: Optional[TreeNode], k: int) -&gt; (int, int):</span><br><span class="line">        if root == None:</span><br><span class="line">            return 0, -1</span><br><span class="line">        else:</span><br><span class="line">            num, ret = self.find(root.left, k)</span><br><span class="line">            if ret == -1:</span><br><span class="line">                if k - num == 1:</span><br><span class="line">                    return -1, root.val</span><br><span class="line">                else:</span><br><span class="line">                    tnum, ret = self.find(root.right, k - num - 1)</span><br><span class="line">                    return tnum + num + 1, ret</span><br><span class="line">            else:</span><br><span class="line">                return -1, ret</span><br><span class="line"></span><br><span class="line">    def kthSmallest(self, root: Optional[TreeNode], k: int) -&gt; int:</span><br><span class="line">        num, ret = self.find(root, k)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-16"><a href="#2021-10-16" class="headerlink" title="2021.10.16"></a>2021.10.16</h1><p><em>今日天气：晴</em></p>
<p><em>人的欲望如同高山上的滚石，一旦开始，就再也停不下来了</em></p>
<p align="right"><em>——超兽武装</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode282.给表达式添加运算符</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。</p>
<p><strong><em>思路</em></strong></p>
<p>爆搜</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    target = 0</span><br><span class="line">    num = &quot;&quot;</span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    def dfs(self, layer, sum, lastmul, lastnum, s):</span><br><span class="line">        if layer == len(self.num):</span><br><span class="line">            if sum == self.target:</span><br><span class="line">                self.ret.append(s)</span><br><span class="line">        else:</span><br><span class="line">            cur = int(self.num[layer])</span><br><span class="line">            self.dfs(layer + 1, sum + cur, cur, cur, s + &quot;+&quot; + str(cur))</span><br><span class="line">            self.dfs(layer + 1, sum - cur, -cur, cur, s + &quot;-&quot; + str(cur))</span><br><span class="line">            self.dfs(layer + 1, sum + lastmul * (cur - 1), lastmul * cur, cur, s + &quot;*&quot; + str(cur))</span><br><span class="line">            if lastnum != 0:</span><br><span class="line">                self.dfs(layer + 1, sum + lastmul // lastnum * (lastnum * 10 + cur) - lastmul, lastmul // lastnum * (lastnum * 10 + cur), lastnum * 10 + cur, s + str(cur))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    def addOperators(self, num: str, target: int) -&gt; List[str]:</span><br><span class="line">        self.ret = []</span><br><span class="line">        self.target = target</span><br><span class="line">        self.num = num</span><br><span class="line">        self.dfs(1, int(num[0]), int(num[0]), int(num[0]), num[0])</span><br><span class="line">        return self.ret</span><br></pre></td></tr></table></figure>
<p><strong><em>C++</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int tar;</span><br><span class="line">    string n;</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line"></span><br><span class="line">    void dfs(int layer, long long sum, long long lastmul, long long lastnum, string s)&#123;</span><br><span class="line">        if(layer == n.length())&#123;</span><br><span class="line">            if(sum == tar)&#123;</span><br><span class="line">                cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">                ret.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            long long cur = n[layer] - &apos;0&apos;;</span><br><span class="line">            dfs(layer + 1, sum + lastmul * (cur - 1), lastmul * cur, cur, s + &apos;*&apos; + n[layer]);</span><br><span class="line">            if(lastnum)&#123;</span><br><span class="line">                dfs(layer + 1, sum + lastmul / lastnum * (10 * lastnum + cur) - lastmul, lastmul / lastnum * (10 * lastnum + cur), 10 * lastnum + cur, s + n[layer]);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(layer + 1, sum + cur, cur, cur, s + &apos;+&apos; + n[layer]);</span><br><span class="line">            dfs(layer + 1, sum - cur, -cur, cur, s + &apos;-&apos; + n[layer]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; addOperators(string num, int target) &#123;</span><br><span class="line">        tar = target;</span><br><span class="line">        n = num;</span><br><span class="line">        dfs(1, num[0] - &apos;0&apos;, num[0] - &apos;0&apos;, num[0] - &apos;0&apos;, num.substr(0, 1));</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-15"><a href="#2021-10-15" class="headerlink" title="2021.10.15"></a>2021.10.15</h1><p><em>今日天气：晴</em></p>
<p><em>我自狂歌空度日，飞扬跋扈为谁雄</em></p>
<p align="right"><em>——赠李白</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode38.外观数列</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定一个正整数 n ，输出外观数列的第 n 项。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>
<pre><code>countAndSay(1) = &quot;1&quot;
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
</code></pre><p>前五项如下：</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221</li>
</ol>
<p>第一项是数字 1<br>描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 “11”<br>描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 “21”<br>描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 “1211”<br>描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 “111221”</p>
<p>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p>
<p><strong><em>Java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String countAndSay(int n) &#123;</span><br><span class="line">        String lst = &quot;&quot;;</span><br><span class="line">        String ret = &quot;1&quot;;</span><br><span class="line">        while(--n &gt; 0)&#123;</span><br><span class="line">            lst = ret;</span><br><span class="line">            ret = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">            int count = 1;</span><br><span class="line">            for(int i = 0; i &lt; lst.length() - 1; ++i)&#123;</span><br><span class="line">                if(lst.charAt(i) == lst.charAt(i + 1))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ret += Integer.toString(count);</span><br><span class="line">                    ret += lst.charAt(i);</span><br><span class="line">                    count = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret += Integer.toString(count);</span><br><span class="line">            ret += lst.charAt(lst.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>C++</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string countAndSay(int n) &#123;</span><br><span class="line">        string lst = &quot;&quot;;</span><br><span class="line">        string ret = &quot;1&quot;;</span><br><span class="line">        while(--n &gt; 0)&#123;</span><br><span class="line">            lst = ret;</span><br><span class="line">            ret = &quot;&quot;;</span><br><span class="line">            int count = 1;</span><br><span class="line">            for(int i = 0; i &lt; lst.length() - 1; ++i)&#123;</span><br><span class="line">                if(lst[i] == lst[i + 1])&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ret += to_string(count);</span><br><span class="line">                    ret += lst[i];</span><br><span class="line">                    count = 1; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += to_string(count);</span><br><span class="line">            ret += lst[lst.length() - 1];</span><br><span class="line">            //cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        last = &quot;&quot;</span><br><span class="line">        ret = &quot;1&quot;</span><br><span class="line">        while n &gt; 1:</span><br><span class="line">            n -= 1</span><br><span class="line">            last = ret</span><br><span class="line">            ret = &quot;&quot;</span><br><span class="line">            count = 1</span><br><span class="line">            for i in range(len(last) - 1):</span><br><span class="line">                if last[i] == last[i + 1]:</span><br><span class="line">                    count += 1</span><br><span class="line">                else:</span><br><span class="line">                    ret += str(count)</span><br><span class="line">                    ret += last[i]</span><br><span class="line">                    count = 1</span><br><span class="line">            ret += str(count)</span><br><span class="line">            ret += last[len(last) - 1]</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><strong><em>语法</em></strong></p>
<p>值得注意的是，C++直接使用string类型的ret和int类型的count相加，这样处理得到的答案是错误的，必须使用全局函数to_string（注意这个是C++11标准的函数，在早先的版本中无法使用）。</p>
<p>猜测可能是把int型自动转换成了char型？</p>
<p>但在本地编译，直接使用string类型加int类型是不通过的。</p>
<h1 id="2021-10-14"><a href="#2021-10-14" class="headerlink" title="2021.10.14"></a>2021.10.14</h1><p><em>今日天气：晴</em></p>
<p><em>长铗归来乎！食无鱼</em></p>
<p align="right"><em>——战国策·冯谖客孟尝君</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode 剑指OfferⅡ.069 山峰数组的顶部</em></p>
<p><strong><em>描述</em></strong></p>
<p>数组arr长度至少为3，满足两端向中间严格递增，找出中间最大值的下标</p>
<p><strong><em>思路</em></strong></p>
<p>三分法</p>
<p>需要注意的地方和二分法类似，即取不取边界的问题，这里下界可以不取，但上界一定要取</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def peakIndexInMountainArray(self, arr: List[int]) -&gt; int:</span><br><span class="line">        l = 0</span><br><span class="line">        h = len(arr) - 1</span><br><span class="line">        while h &gt; l:</span><br><span class="line">            lm = (2 * l + h) // 3</span><br><span class="line">            hm = (l + 2 * h) // 3</span><br><span class="line">            if arr[lm] == arr[hm]:</span><br><span class="line">                l = lm</span><br><span class="line">                h = hm</span><br><span class="line">            elif arr[lm] &lt; arr[hm]:</span><br><span class="line">                l = lm + 1</span><br><span class="line">            else:</span><br><span class="line">                h = hm</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-13"><a href="#2021-10-13" class="headerlink" title="2021.10.13"></a>2021.10.13</h1><p><em>今日天气：晴</em></p>
<p><em>宁赴常流而葬乎江鱼腹中耳。又安能以皓皓之白，而蒙世之温蠖乎？</em></p>
<p align="right"><em>——史记·屈原列传</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode.412 Fizz Buzz</em></p>
<p><strong><em>描述</em></strong></p>
<p>给出数字n，从1到n的数里面，若能被3整除则对应Fizz，能被5整除则对应Buzz，同时被两者整除的对应FizzBuzz，否则对应原数字，返回字符串组成的数组</p>
<p><strong><em>C++</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; fizzBuzz(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; r;</span><br><span class="line">        for(int i = 1; i &lt;= n; ++i)&#123;</span><br><span class="line">            string ret = &quot;&quot;;</span><br><span class="line">            if(i % 3 == 0)&#123;</span><br><span class="line">                ret += &quot;Fizz&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i % 5 == 0)&#123;</span><br><span class="line">                ret += &quot;Buzz&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ret == &quot;&quot;)&#123;</span><br><span class="line">                ret = to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">            r.push_back(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>Java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; fizzBuzz(int n) &#123;</span><br><span class="line">        List&lt;String&gt; ret = new LinkedList&lt;&gt;();</span><br><span class="line">        for(int i = 1; i &lt;= n; ++i)&#123;</span><br><span class="line">            String r = &quot;&quot;;</span><br><span class="line">            if(i % 3 == 0)&#123;</span><br><span class="line">                r += &quot;Fizz&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i % 5 == 0)&#123;</span><br><span class="line">                r += &quot;Buzz&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            if(r.equals(&quot;&quot;))&#123;</span><br><span class="line">                r = Integer.toString(i);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fizzBuzz(self, n: int) -&gt; List[str]:</span><br><span class="line">        r = []</span><br><span class="line">        for i in range(1, n + 1):</span><br><span class="line">            ret = &quot;&quot;</span><br><span class="line">            if i % 3 == 0:</span><br><span class="line">                ret += &quot;Fizz&quot;</span><br><span class="line">            if i % 5 == 0:</span><br><span class="line">                ret += &quot;Buzz&quot;</span><br><span class="line">            if ret == &quot;&quot;:</span><br><span class="line">                ret = str(i)</span><br><span class="line">            r.append(ret)</span><br><span class="line">        return r</span><br></pre></td></tr></table></figure>
<p><strong><em>语法</em></strong></p>
<p>1.Java的int转String</p>
<p>int是基本类型，不能看作对象，没有toString方法，一种方法是使用String类的静态方法valueOf，另一种方法是使用Integer类的静态方法toString，还可以新建一个值相等的Integer对象，再利用其toString方法</p>
<h1 id="2021-10-12"><a href="#2021-10-12" class="headerlink" title="2021.10.12"></a>2021.10.12</h1><p><em>今日天气：晴</em></p>
<p><em>沉吟此事泪满衣，黄金买醉未能归</em></p>
<p align="right"><em>——梁园吟</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode.29 两数相除</em></p>
<p><strong><em>描述</em></strong></p>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<p>如果结果超过了32位有符号整形的范围，返回0x7fffffff</p>
<p><strong><em>思路</em></strong></p>
<p>模拟实现二进制除法，先判断符号</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def divide(self, dividend: int, divisor: int) -&gt; int:</span><br><span class="line">        sign = True</span><br><span class="line">        if dividend &lt; 0:</span><br><span class="line">            sign = not sign</span><br><span class="line">            dividend = -dividend</span><br><span class="line">        if divisor &lt; 0:</span><br><span class="line">            sign = not sign</span><br><span class="line">            divisor = -divisor</span><br><span class="line">        temp = 0</span><br><span class="line">        while dividend &gt;= divisor:</span><br><span class="line">            divisor &lt;&lt;= 1</span><br><span class="line">            temp += 1</span><br><span class="line">        divisor &gt;&gt;= 1</span><br><span class="line">        ret = 0</span><br><span class="line">        for i in range(temp):</span><br><span class="line">            ret &lt;&lt;= 1</span><br><span class="line">            if dividend &gt;= divisor:</span><br><span class="line">                dividend -= divisor</span><br><span class="line">                ret += 1</span><br><span class="line">            divisor &gt;&gt;= 1</span><br><span class="line">        if not sign:</span><br><span class="line">            ret = -ret</span><br><span class="line">        if ret &gt; 0x7fffffff or ret &lt; -0x80000000:</span><br><span class="line">            ret = 0x7fffffff</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><strong><em>Java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int divide(int dividend, int divisor) &#123;</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        long tdividend = dividend;</span><br><span class="line">        long tdivisor = divisor;</span><br><span class="line">        if(tdividend &lt; 0)&#123;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            tdividend = -tdividend;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tdivisor &lt; 0)&#123;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            tdivisor = -tdivisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(tdividend &gt;= tdivisor)&#123;</span><br><span class="line">            tdivisor &lt;&lt;= 1;</span><br><span class="line">            ++temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long ret = 0;</span><br><span class="line">        tdivisor &gt;&gt;= 1;</span><br><span class="line">        for(int i = 0; i &lt; temp; ++i)&#123;</span><br><span class="line">            ret &lt;&lt;= 1;</span><br><span class="line">            if(tdividend &gt;= tdivisor)&#123;</span><br><span class="line">                tdividend -= tdivisor;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">            tdivisor &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            ret = -ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(ret &gt; Integer.MAX_VALUE || ret &lt; Integer.MIN_VALUE)&#123;</span><br><span class="line">            ret = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (int)ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>C++</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int divide(int dividend, int divisor) &#123;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        long long tdividend = dividend;</span><br><span class="line">        long long tdivisor = divisor;</span><br><span class="line">        if(tdividend &lt; 0)&#123;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            tdividend = -tdividend;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tdivisor &lt; 0)&#123;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            tdivisor = -tdivisor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int temp = 0;</span><br><span class="line">        while(tdividend &gt;= tdivisor)&#123;</span><br><span class="line">            tdivisor &lt;&lt;= 1;</span><br><span class="line">            ++temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long long ret = 0;</span><br><span class="line">        tdivisor &gt;&gt;= 1;</span><br><span class="line">        for(int i = 0; i &lt; temp; ++i)&#123;</span><br><span class="line">            ret &lt;&lt;= 1;</span><br><span class="line">            if(tdividend &gt;= tdivisor)&#123;</span><br><span class="line">                tdividend -= tdivisor;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">            tdivisor &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(!flag)&#123;</span><br><span class="line">            ret = -ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //cout &lt;&lt; -0x80000000;</span><br><span class="line"></span><br><span class="line">        if(ret &gt; 0x7fffffff || ret &lt; -(long long)0x80000000)&#123;</span><br><span class="line">            ret = 0x7fffffff;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (int)ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>语法</em></strong></p>
<p>1.有意思的0x80000000</p>
<p>假设long long ret = 1，我们看下面几个表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret &lt; 0x80000000</span><br><span class="line">ret &lt; -0x80000000</span><br><span class="line">ret &lt; (long long)-0x80000000</span><br><span class="line">ret &lt; -(long long)0x80000000</span><br><span class="line">ret &lt; (int)0x80000000</span><br></pre></td></tr></table></figure>
<p>它们的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>这里就要说一下C语言的常数判断规则了：</p>
<p>一个常数，如果在有符号int型范围内，就判断它为有符号int型，如果超出，则扩展为unsigned int，如果还不够，就扩展为long long，再到unsigned long long，再超还是按unsigned long long但会对64位取模</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a = 1;</span><br><span class="line">	printf(&quot;%d\n&quot;, a &lt; 0x80000000);</span><br><span class="line">	printf(&quot;%d\n&quot;, sizeof(0x80000000));</span><br><span class="line">	printf(&quot;%d\n&quot;, sizeof(0x800000000));</span><br><span class="line">	printf(&quot;%d\n&quot;, sizeof(0x8000000000000000));</span><br><span class="line">	printf(&quot;%d\n&quot;, sizeof(0x8000000000000001));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>这时，我们再引入运算规则，两个不同类型的数进行运算，范围较小的会自动向范围较大的扩展，其顺序是int-&gt;unsigned int-&gt;long long-&gt;unsigned long long。</p>
<p>需要注意的是，int和unsigned int本质上是一种类型，长度和内部的存储都一样，只不过可以看成是一种数的两种解读方式</p>
<p>下面我们逐个分析：</p>
<p>1.ret &lt; 0x80000000</p>
<p>0x80000000是unsigned int型，和ret比较自动转为long long值不变，比1大</p>
<p>2.ret &lt; -0x80000000</p>
<p>这里为什么还是true呢？因为0x80000000是unsigned int型，取负运算是把它转为int型下做的，做完之后不变，还是0x80000000</p>
<p>3.ret &lt; (long long)-0x80000000</p>
<p>同上，取负是在int型下做的，值不变</p>
<p>4.ret &lt; -(long long)0x80000000</p>
<p>这里的是先转为long long，再取负数，当然就变成负数了</p>
<p>5.ret &lt; (int)0x80000000</p>
<p>强制将值按int型解释，解释出的值是负数</p>
<h1 id="2021-10-11"><a href="#2021-10-11" class="headerlink" title="2021.10.11"></a>2021.10.11</h1><p><em>今日天气:晴</em></p>
<p><em>古来圣贤皆寂寞，唯有饮者留其名。</em></p>
<p align="right"><em>——将进酒</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode273.整数转换英文表示</em></p>
<p><strong><em>描述</em></strong></p>
<p>将非负整数 num 转换为其对应的英文表示，范围是正数int范围</p>
<p><strong><em>思路</em></strong></p>
<p>正数int范围的话，最多10位整数，英文的习惯是每3位为一组，后分别加Thousand，Million，Billion，所以可以把num分开讨论</p>
<p>注意空格的问题和0的表示</p>
<p>由于本题麻烦，所以不写C++和Java代码了</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    words = [   &quot;Zero&quot;,</span><br><span class="line">                &quot;One&quot;, </span><br><span class="line">                &quot;Two&quot;, </span><br><span class="line">                &quot;Three&quot;, </span><br><span class="line">                &quot;Four&quot;, </span><br><span class="line">                &quot;Five&quot;, </span><br><span class="line">                &quot;Six&quot;, </span><br><span class="line">                &quot;Seven&quot;, </span><br><span class="line">                &quot;Eight&quot;, </span><br><span class="line">                &quot;Nine&quot;, </span><br><span class="line">                &quot;Ten&quot;, </span><br><span class="line">                &quot;Eleven&quot;, </span><br><span class="line">                &quot;Twelve&quot;, </span><br><span class="line">                &quot;Thirteen&quot;,</span><br><span class="line">                &quot;Fourteen&quot;,</span><br><span class="line">                &quot;Fifteen&quot;, </span><br><span class="line">                &quot;Sixteen&quot;, </span><br><span class="line">                &quot;Seventeen&quot;, </span><br><span class="line">                &quot;Eighteen&quot;, </span><br><span class="line">                &quot;Nineteen&quot;, </span><br><span class="line">                &quot;Twenty&quot;, </span><br><span class="line">                &quot;Thirty&quot;, </span><br><span class="line">                &quot;Forty&quot;, </span><br><span class="line">                &quot;Fifty&quot;, </span><br><span class="line">                &quot;Sixty&quot;, </span><br><span class="line">                &quot;Seventy&quot;, </span><br><span class="line">                &quot;Eighty&quot;, </span><br><span class="line">                &quot;Ninety&quot;,</span><br><span class="line">            ]</span><br><span class="line">    def numberToWords(self, num: int) -&gt; str:</span><br><span class="line">        ret = &quot;&quot;</span><br><span class="line">        flag = True</span><br><span class="line">        if num &gt;= 1000000000:</span><br><span class="line">            ret += self.numberToWords(num // 1000000000)</span><br><span class="line">            num %= 1000000000</span><br><span class="line">            ret += &quot; Billion&quot;</span><br><span class="line">            flag = False</span><br><span class="line">        if num &gt;= 1000000:</span><br><span class="line">            if flag:</span><br><span class="line">                flag = False</span><br><span class="line">            else:</span><br><span class="line">                ret += &quot; &quot;</span><br><span class="line">            ret += self.numberToWords(num // 1000000)</span><br><span class="line">            num %= 1000000</span><br><span class="line">            ret += &quot; Million&quot;</span><br><span class="line">        if num &gt;= 1000:</span><br><span class="line">            if flag:</span><br><span class="line">                flag = False</span><br><span class="line">            else:</span><br><span class="line">                ret += &quot; &quot;</span><br><span class="line">            ret += self.numberToWords(num // 1000)</span><br><span class="line">            num %= 1000</span><br><span class="line">            ret += &quot; Thousand&quot;</span><br><span class="line">        if num &gt;= 100:</span><br><span class="line">            if flag:</span><br><span class="line">                flag = False</span><br><span class="line">            else:</span><br><span class="line">                ret += &quot; &quot;</span><br><span class="line">            ret += self.words[num // 100]</span><br><span class="line">            ret += &quot; Hundred&quot;</span><br><span class="line">            num %= 100</span><br><span class="line">        if num &gt;= 20:</span><br><span class="line">            if flag:</span><br><span class="line">                flag = False</span><br><span class="line">            else:</span><br><span class="line">                ret += &quot; &quot;</span><br><span class="line">            ret += self.words[num // 10 + 18]</span><br><span class="line">            num %= 10</span><br><span class="line">            if num &gt; 0:</span><br><span class="line">                if flag:</span><br><span class="line">                    flag = False</span><br><span class="line">                else:</span><br><span class="line">                    ret += &quot; &quot;</span><br><span class="line">                ret += self.words[num]</span><br><span class="line">        elif num &gt; 0:</span><br><span class="line">            if flag:</span><br><span class="line">                flag = False</span><br><span class="line">            else:</span><br><span class="line">                ret += &quot; &quot;</span><br><span class="line">            ret += self.words[num]</span><br><span class="line">        else:</span><br><span class="line">            if flag:</span><br><span class="line">                ret += self.words[num]</span><br><span class="line">                flag = False</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><em>这里不用递归，直接把每组的转换摘出来就能提升一些效率</em></p>
<h1 id="2021-10-10"><a href="#2021-10-10" class="headerlink" title="2021.10.10"></a>2021.10.10</h1><p><em>今日天气：雾</em></p>
<p><em>不要为明天忧虑，因为明天自有明天的忧虑，一天的难处一天当就好了</em></p>
<p align="right"><em>——新约·马太福音</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode.441 排列硬币</em></p>
<p><strong><em>描述</em></strong></p>
<p>你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。</p>
<p>给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。</p>
<p><strong><em>思路</em></strong></p>
<p>很简单的数学题，找出最大的满足(k+1)×k &gt;= n的n即可。</p>
<p><strong><em>Python</em></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrangeCoins</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        k = int((<span class="number">2</span> * n + <span class="number">0.25</span>) ** <span class="number">0.5</span> - <span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure>
<p><strong><em>Java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.sqrt((<span class="keyword">double</span>)n * <span class="number">2.0</span> + <span class="number">0.25</span>) - <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>C++</em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(<span class="number">2</span> * (<span class="keyword">double</span>)n + <span class="number">0.25</span>) - <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>语法</em></strong></p>
<p>1.开方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C++:	sqrt(x);</span><br><span class="line">Java:	Math.sqrt(x);</span><br><span class="line">Python:	x ** 0.5</span><br></pre></td></tr></table></figure>
<p>2.取整</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C++:	(int)x;</span><br><span class="line">Java:	(int)x;</span><br><span class="line">Python:	int(x)</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-8"><a href="#2021-10-8" class="headerlink" title="2021.10.8"></a>2021.10.8</h1><p><em>今日天气：雨</em></p>
<p><em>凡有的，还要加给他，叫他有余；凡没有的，连他所有的也要夺去。</em></p>
<p align="right"><em>——新约·马太福音</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode187.重复的DNA序列</em></p>
<p><strong><em>描述</em></strong></p>
<p>所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p><strong><em>思路</em></strong></p>
<p>使用哈希表存储子串出现次数，做到不重不漏</p>
<p><strong><em>C++</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        map&lt;string, int&gt; mp;</span><br><span class="line">        if(s.length() &gt; 10)&#123;</span><br><span class="line">            for(int i = 0; i &lt; s.length() - 9; ++i)&#123;</span><br><span class="line">                string t = s.substr(i, 10);</span><br><span class="line">                if(mp[t] == 1)&#123;</span><br><span class="line">                    ret.push_back(t);</span><br><span class="line">                &#125;</span><br><span class="line">                ++mp[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findRepeatedDnaSequences(self, s: str) -&gt; List[str]:</span><br><span class="line">        ret = []</span><br><span class="line">        if len(s) &gt; 10:</span><br><span class="line">            d = collections.defaultdict(int)</span><br><span class="line">            for i in range(0, len(s) - 9):</span><br><span class="line">                cur = s[i : i + 10]</span><br><span class="line">                if d[cur] == 1:</span><br><span class="line">                    ret.append(cur)</span><br><span class="line">                d[cur] += 1</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><strong><em>Java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;</span><br><span class="line">        List&lt;String&gt; ret = new LinkedList&lt;&gt;();</span><br><span class="line">        if(s.length() &gt; 10)&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; mp = new HashMap&lt;&gt;();</span><br><span class="line">            for(int i = 0; i &lt; s.length() - 9; ++i)&#123;</span><br><span class="line">                String cur = s.substring(i, i + 10);</span><br><span class="line">                if(mp.get(cur) != null)&#123;</span><br><span class="line">                    if(mp.get(cur) == 1)&#123;</span><br><span class="line">                        ret.add(cur);</span><br><span class="line">                        mp.put(cur, 2);</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    mp.put(cur, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>语法复习</em></strong></p>
<p>1.关于子串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++：string.substr(int 起始下标, int 子串长度)</span><br><span class="line"></span><br><span class="line">Java：String.substring(int 起始下标, int 结束下标)//不包括结束下标</span><br><span class="line"></span><br><span class="line">Python：字符串名\[起始下标 : 结束下标\]//直接数组操作，不包括结束下标</span><br></pre></td></tr></table></figure>
<p>2.关于map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C++：</span><br><span class="line">声明：map&lt;string, int&gt; mp;</span><br><span class="line">赋值：下标</span><br><span class="line">读取：下标</span><br><span class="line">查找：下标，不存在的为0</span><br><span class="line"></span><br><span class="line">Java：</span><br><span class="line">声明：Map&lt;String, Integer&gt; mp = new HashMap&lt;&gt;();</span><br><span class="line">赋值：put(key, value);</span><br><span class="line">读取：get(key);//不存在为null</span><br><span class="line">查找：containsKey(key);</span><br><span class="line"></span><br><span class="line">Python；(字典)</span><br><span class="line">声明：d = collections.defaultdict(int)</span><br><span class="line">赋值：下标</span><br><span class="line">读取：下标</span><br><span class="line">查找：下标，不存在的为0</span><br></pre></td></tr></table></figure>
<p>3.关于vector，List，Arrays</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C++：Vector</span><br><span class="line">声明：Vector&lt;int&gt; ret;</span><br><span class="line">添加：push_back(value);</span><br><span class="line"></span><br><span class="line">Java：List</span><br><span class="line">声明：List&lt;String&gt; ret = new LinkedList&lt;&gt;();//还可以使用ArrayList</span><br><span class="line">添加：add(value);</span><br><span class="line"></span><br><span class="line">Python：Arrays</span><br><span class="line">声明：ret = []</span><br><span class="line">添加：append(value)</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-7"><a href="#2021-10-7" class="headerlink" title="2021.10.7"></a>2021.10.7</h1><p><em>今日天气：阴/下午转雨</em></p>
<p><em>现在他只看到星星和墓碑，但这却是两样最能象征永恒的东西。</em></p>
<p align="right"><em>——三体·黑暗森林</em></p>

<p><strong>今日编程练习</strong></p>
<p><em>Leetcode434.字符串中的单词数</em></p>
<p><strong><em>描述</em></strong></p>
<p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>
<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<p><strong><em>思路</em></strong></p>
<p>遍历数组，设置标记表示前面是否为空格，若前面是空格后面不是，改变标记并计数；前面不是空格后面是，改变标记不计数</p>
<p><strong><em>Python代码</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        ret = 0</span><br><span class="line">        flag = False</span><br><span class="line">        for i in s:</span><br><span class="line">            if i == &apos; &apos; and flag:</span><br><span class="line">                flag = False</span><br><span class="line">            elif i != &apos; &apos; and not flag:</span><br><span class="line">                flag = True</span><br><span class="line">                ret += 1</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><strong><em>Java代码</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSegments(String s) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        for(int i = 0; i &lt; s.length(); ++i)&#123;</span><br><span class="line">            if(flag &amp;&amp; s.charAt(i) == &apos; &apos;)&#123;</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;else if(!flag &amp;&amp; s.charAt(i) != &apos; &apos;)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>C++代码</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countSegments(string s) &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.length(); ++i)&#123;</span><br><span class="line">            if(flag &amp;&amp; s[i] == &apos; &apos;)&#123;</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;else if(!flag &amp;&amp; s[i] != &apos; &apos;)&#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-6"><a href="#2021-10-6" class="headerlink" title="2021.10.6"></a>2021.10.6</h1><p><em>今日天气：阴/风</em></p>
<p><em>人的天性生来不适宜欢乐，只会紧紧地抱住痛苦</em></p>
<p align="right">——基督山伯爵</p>

<p><strong>今日练习</strong></p>
<p><em>Leetcode414.第三大的数</em></p>
<p><strong><em>描述</em></strong></p>
<p>给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。</p>
<p><strong><em>解题思路</em></strong></p>
<p>如果题目只要一个最大值的话，我们会用类似于“打擂台”的方法，一个最大值变量来记录当前最大值，然后再一个个地比较下去</p>
<p>但题目要第三大值，我们仍然可以使用“打擂台”的方法，只不过这次需要记录最大，次大，第三大这三个值，每次拿新数去和它们比较</p>
<p>只需要遍历一次时间复杂度是O(N)，空间复杂度是O(1)</p>
<blockquote>
<p>还有一种类似于快速排序的方法也可以在O(n)时间复杂度下求出第k大数，详见<a href="https://jameci.github.io/2021/03/22/%E7%AC%ACk%E5%A4%A7%E6%95%B0/" target="_blank" rel="noopener">https://jameci.github.io/2021/03/22/%E7%AC%ACk%E5%A4%A7%E6%95%B0/</a></p>
</blockquote>
<p><strong><em>代码Python</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def thirdMax(self, nums: List[int]) -&gt; int:</span><br><span class="line">        m = [nums[0]]</span><br><span class="line">        for i in range(1, len(nums)):</span><br><span class="line">            cur = nums[i]</span><br><span class="line">            if len(m) == 1:</span><br><span class="line">                if cur &gt; m[0]:</span><br><span class="line">                    m.append(m[0])</span><br><span class="line">                    m[0] = cur</span><br><span class="line">                elif cur &lt; m[0]:</span><br><span class="line">                    m.append(cur)</span><br><span class="line">            elif len(m) == 2:</span><br><span class="line">                if cur &gt; m[0]:</span><br><span class="line">                    m.append(m[1])</span><br><span class="line">                    m[1] = m[0]</span><br><span class="line">                    m[0] = cur</span><br><span class="line">                elif cur &lt; m[0]:</span><br><span class="line">                    if cur &gt; m[1]:</span><br><span class="line">                        m.append(m[1])</span><br><span class="line">                        m[1] = cur</span><br><span class="line">                    elif cur &lt; m[1]:</span><br><span class="line">                        m.append(cur)</span><br><span class="line">            else:</span><br><span class="line">                if cur &gt; m[0]:</span><br><span class="line">                    m[2] = m[1]</span><br><span class="line">                    m[1] = m[0]</span><br><span class="line">                    m[0] = cur</span><br><span class="line">                elif cur &lt; m[0]:</span><br><span class="line">                    if cur &gt; m[1]:</span><br><span class="line">                        m[2] = m[1]</span><br><span class="line">                        m[1] = cur</span><br><span class="line">                    elif cur &lt; m[1]:</span><br><span class="line">                        if cur &gt; m[2]:</span><br><span class="line">                            m[2] = cur</span><br><span class="line"></span><br><span class="line">        if len(m) == 3:</span><br><span class="line">            return m[2]</span><br><span class="line">        else:</span><br><span class="line">            return m[0]</span><br></pre></td></tr></table></figure>
<p><strong><em>代码Java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int thirdMax(int[] nums) &#123;</span><br><span class="line">        int count = 1;</span><br><span class="line">        int[] temp = new int[3];</span><br><span class="line">        temp[0] = nums[0];</span><br><span class="line">        for(int i = 1; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            if(count == 1)&#123;</span><br><span class="line">                if(nums[i] &gt; temp[0])&#123;</span><br><span class="line">                    temp[1] = temp[0];</span><br><span class="line">                    temp[0] = nums[i];</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;else if(nums[i] &lt; temp[0])&#123;</span><br><span class="line">                    temp[1] = nums[i];</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(count == 2)&#123;</span><br><span class="line">                if(nums[i] &gt; temp[0])&#123;</span><br><span class="line">                    temp[2] = temp[1];</span><br><span class="line">                    temp[1] = temp[0];</span><br><span class="line">                    temp[0] = nums[i];</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;else if(nums[i] &lt; temp[0])&#123;</span><br><span class="line">                    if(nums[i] &gt; temp[1])&#123;</span><br><span class="line">                        temp[2] = temp[1];</span><br><span class="line">                        temp[1] = nums[i];</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;else if(nums[i] &lt; temp[1])&#123;</span><br><span class="line">                        temp[2] = nums[i];</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(nums[i] &gt; temp[0])&#123;</span><br><span class="line">                    temp[2] = temp[1];</span><br><span class="line">                    temp[1] = temp[0];</span><br><span class="line">                    temp[0] = nums[i];</span><br><span class="line">                &#125;else if(nums[i] &lt; temp[0])&#123;</span><br><span class="line">                    if(nums[i] &gt; temp[1])&#123;</span><br><span class="line">                        temp[2] = temp[1];</span><br><span class="line">                        temp[1] = nums[i];</span><br><span class="line">                    &#125;else if(nums[i] &lt; temp[1])&#123;</span><br><span class="line">                        if(nums[i] &gt; temp[2])&#123;</span><br><span class="line">                            temp[2] = nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count == 3)&#123;</span><br><span class="line">            return temp[2];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return temp[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-4"><a href="#2021-10-4" class="headerlink" title="2021.10.4"></a>2021.10.4</h1><p><em>今日天气：晴</em></p>
<p><em>有什么能阻挡一个男人扬帆起航？</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日练习</strong></p>
<p><em>Leetcode482.密钥格式化</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p>
<p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p>
<p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<p><strong><em>思路</em></strong></p>
<p>暴力模拟即可</p>
<p><strong><em>python解法</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def licenseKeyFormatting(self, s: str, k: int) -&gt; str:</span><br><span class="line">        l = len(s)</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] == &apos;-&apos;:</span><br><span class="line">                l -= 1</span><br><span class="line">        lst = l % k</span><br><span class="line">        if lst == 0:</span><br><span class="line">            lst = k</span><br><span class="line">        </span><br><span class="line">        ret = &apos;&apos;</span><br><span class="line">        num = lst</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] == &apos;-&apos;:</span><br><span class="line">                continue</span><br><span class="line">            elif s[i].islower():</span><br><span class="line">                ret += s[i].upper()</span><br><span class="line">            else:</span><br><span class="line">                ret += s[i]</span><br><span class="line">            num -= 1</span><br><span class="line">            l -= 1</span><br><span class="line">            if num == 0 and l != 0:</span><br><span class="line">                num = k</span><br><span class="line">                ret += &apos;-&apos;</span><br><span class="line"></span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><strong><em>Java解法</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">licenseKeyFormatting</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        s = s.replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> startpos = s.length() % k == <span class="number">0</span> ? Math.min(k, s.length()) : s.length() % k;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder(s.substring(<span class="number">0</span>, startpos));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startpos; i &lt; s.length(); i += k)&#123;</span><br><span class="line">            ret.append(<span class="string">"-"</span>);</span><br><span class="line">            ret.append(s.substring(i, i + k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-3"><a href="#2021-10-3" class="headerlink" title="2021.10.3"></a>2021.10.3</h1><p><em>今日天气：晴</em></p>
<p><em>历经苦难而不厌，此乃修罗之道！</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode166.分数到小数</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<p>如果存在多个答案，只需返回 任意一个 。</p>
<p>对于所有给定的输入，保证 答案字符串的长度小于 10^4 。</p>
<p><strong><em>思路</em></strong></p>
<p>循环小数分为两种，纯循环和混循环，纯循环如1/3=0.33333……，这里小数部分只要循环节3，而混循环如1/6=0.166666……，这里6是循环节，而小数部分不仅仅是由循环节6组成，还有一个1</p>
<p>我们再引入形如9，99，999，9999，99999这样只有9组成的数，这样的数做分母的真分数化为小数有一个特殊性质——它们都是纯循环小数，循环节长度等于9的个数，并且循环节就是带前导零的分子本身</p>
<p>如1/9=0.11111……，1/99=0.0101……，56/999=0.056056……</p>
<p>因此，所有的纯循环小数都可以化为这种特定形式的分数，以1/7=0.142857……为例，循环节为142857，所以有：</p>
<p>1/7 = 142857/999999 = 0.142857……</p>
<p>那么，假设我们要计算1/7，那么其实我们只需要找到一个全是9组成的数x，令x能被7整除，自然就可以把1/7化为上面这种形式的分数，然后直接得到循环节</p>
<p>那么混循环怎么办，我们再引出一个结论，所有混循环小数的分母上一定带有因子2或因子5，如1/6=0.1666……，1/15=0.06666……，这是为什么呢？因为2和5是10的因数，所以十进制下的任何整数都可以被其因数仅仅含有2，5的除尽。比如任何整数除以10，20，50，25，8，125，都肯定是能除得尽的。</p>
<p>这造成了混循环，为什么这么说呢，例如1/14，实际上相当于1先除以2，再除以7，也就变成了0.5除以7，这时循环节和5除以7的循环节是一模一样的，只不过因为先除以2的存在，小数点后移了一位，造成小数部分的第一位不是循环节的一部分，产生了混循环</p>
<p>经过上面的分析，如何处理混循环的思路也很明确了，先做一个预处理：即先把分母中的因子2，5去掉，如果分子也含2，5，先约分，如果不含，分子分母同时除以2或5，但这样做会在预处理时把分子变成小数，为了避免这样，我们可以换种方式，用一个变量记录混循环的位数，我们知道，每当分子分母同时除以10，相当于小数点后移一位，混循环位数加1，我们利用混循环位数加1的操作代替分子除以10，来避免预处理时把分子变成小数，具体做法是先约分2和5，之后，如果分母中有多余的一对2和5，则分母除以10，记录混循环位数加一，不再对分子进行处理，同理，如果分母只有多余的2，我们就除掉它，并给分子乘5，再记录小数点后混循环位数加1，若只有多余的5，我们就除掉它，并给分子乘2，混循环位数加1</p>
<p>剔除2和5之后，再按照处理纯循环的方式处理</p>
<p>最后，还需要针对结果为负数以及结果是0的情况进行一下特殊判断</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fractionToDecimal(self, numerator: int, denominator: int) -&gt; str:</span><br><span class="line">        ret = &apos;&apos;</span><br><span class="line">        if numerator == 0:</span><br><span class="line">            return &apos;0&apos;</span><br><span class="line">        elif numerator &lt; 0 and denominator &lt; 0:</span><br><span class="line">            denominator = -denominator</span><br><span class="line">            numerator = -numerator</span><br><span class="line">        elif numerator &lt; 0:</span><br><span class="line">            ret += &apos;-&apos;</span><br><span class="line">            numerator = -numerator</span><br><span class="line">        elif denominator &lt; 0:</span><br><span class="line">            ret += &apos;-&apos;</span><br><span class="line">            denominator = -denominator</span><br><span class="line">        ret += str(numerator // denominator)</span><br><span class="line">        numerator %= denominator</span><br><span class="line">        if numerator != 0:</span><br><span class="line">            ret += &quot;.&quot;</span><br><span class="line">            temp_denominator = 0</span><br><span class="line">            while denominator % 2 == 0:</span><br><span class="line">                denominator //= 2</span><br><span class="line">                if numerator % 2 == 0:</span><br><span class="line">                    numerator //= 2</span><br><span class="line">                else:</span><br><span class="line">                    if denominator % 5 == 0:</span><br><span class="line">                        denominator //= 5</span><br><span class="line">                    else:</span><br><span class="line">                        numerator *= 5</span><br><span class="line">                    temp_denominator += 1</span><br><span class="line">            while denominator % 5 == 0:</span><br><span class="line">                if numerator % 5 == 0:</span><br><span class="line">                    numerator //= 5</span><br><span class="line">                else:</span><br><span class="line">                    denominator //= 5</span><br><span class="line">                    temp_denominator += 1</span><br><span class="line">                    numerator *= 2</span><br><span class="line">            temp_denominator2 = 1</span><br><span class="line">            if denominator == 1:</span><br><span class="line">                temp_denominator2 = 0</span><br><span class="line">            else:</span><br><span class="line">                while ((10 ** temp_denominator2) - 1) % denominator != 0:</span><br><span class="line">                    temp_denominator2 += 1</span><br><span class="line">            print(temp_denominator)</span><br><span class="line">            print(temp_denominator2)</span><br><span class="line">            print(numerator)</span><br><span class="line">            if temp_denominator2 == 0:</span><br><span class="line">                ret += (&apos;0&apos; * (temp_denominator - len(str(numerator))))</span><br><span class="line">                ret += str(numerator)</span><br><span class="line">            else:</span><br><span class="line">                numerator *= (((10 ** temp_denominator2) - 1) // denominator)</span><br><span class="line">                if temp_denominator != 0:</span><br><span class="line">                    part1 = numerator // ((10 ** temp_denominator2) - 1) </span><br><span class="line">                    ret += (&apos;0&apos; * (temp_denominator - len(str(part1))))</span><br><span class="line">                    ret += str(part1)</span><br><span class="line">                ret += &apos;(&apos;</span><br><span class="line">                part2 = numerator % ((10 ** temp_denominator2) - 1)</span><br><span class="line">                ret += (&apos;0&apos; * (temp_denominator2 - len(str(part2))))</span><br><span class="line">                ret += str(part2)</span><br><span class="line">                ret += &apos;)&apos;</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-2"><a href="#2021-10-2" class="headerlink" title="2021.10.2"></a>2021.10.2</h1><p><em>今日天气：晴</em></p>
<p><em>灾难总是接踵而至，这正是世间的常理，你以为只要解释一下，就有谁会来救你吗？要是死了，就只能说明我不过是如此程度的男人</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode405.数字转换为十六进制数</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p>
<p>注意:</p>
<pre><code>十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符&apos;0&apos;来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
</code></pre><p><strong><em>思路</em></strong></p>
<p>直接转换比较容易，但补码较为麻烦，可以使用加上0x100000000的方法，让负数也变成正数，之后再按位转换</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def toHex(self, num: int) -&gt; str:</span><br><span class="line">        if num &lt; 0:</span><br><span class="line">            num += 0x100000000</span><br><span class="line">        elif num == 0:</span><br><span class="line">            return &apos;0&apos;</span><br><span class="line">        ret = &apos;&apos;</span><br><span class="line">        while num &gt; 0:</span><br><span class="line">            if num % 16 &lt; 10:</span><br><span class="line">                ret = str(num % 16) + ret</span><br><span class="line">            elif num % 16 == 10:</span><br><span class="line">                ret = &apos;a&apos; + ret</span><br><span class="line">            elif num % 16 == 11:</span><br><span class="line">                ret = &apos;b&apos; + ret</span><br><span class="line">            elif num % 16 == 12:</span><br><span class="line">                ret = &apos;c&apos; + ret</span><br><span class="line">            elif num % 16 == 13:</span><br><span class="line">                ret = &apos;d&apos; + ret</span><br><span class="line">            elif num % 16 == 14:</span><br><span class="line">                ret = &apos;e&apos; + ret</span><br><span class="line">            else:</span><br><span class="line">                ret = &apos;f&apos; + ret</span><br><span class="line">            num //= 16</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-10-1"><a href="#2021-10-1" class="headerlink" title="2021.10.1"></a>2021.10.1</h1><p><em>今日天气：晴</em></p>
<p><em>一个人诞生在这个世界上，绝对不会是永远孤单的</em></p>
<p align="right"><em>——海贼王</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode1436.旅行终点站</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p>
<p><strong><em>思路</em></strong></p>
<p>统计出度，肯定只有旅行终点站的出度是0</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def destCity(self, paths: List[List[str]]) -&gt; str:</span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        for a, b in paths:</span><br><span class="line">            d[a] += 1</span><br><span class="line">        </span><br><span class="line">        for a, b in paths:</span><br><span class="line">            if d[b] == 0:</span><br><span class="line">                return b</span><br></pre></td></tr></table></figure>
<p><strong><em>语法复习</em></strong></p>
<p>创建字典d = collections.defaultdict(int)</p>
<h1 id="2021-9-30"><a href="#2021-9-30" class="headerlink" title="2021.9.30"></a>2021.9.30</h1><p><em>今日天气：晴</em></p>
<p><em>你将拔掉龙的牙齿，将狮子踩在脚下！</em></p>
<p align="right"><em>——基督山伯爵</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode223.矩形面积</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。</p>
<p>每个矩形由其 左下 顶点和 右上 顶点坐标表示：</p>
<pre><code>第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。
第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。
</code></pre><p><strong><em>思路</em></strong></p>
<p>已知四个端点，判断两个线段不相交的方法是，若某个线段的左端点在另一线段的右端点右方，或者其右端点在另一线段的左端点左方，则不相交，否则相交</p>
<p>可以把矩形投影到x轴上，如果两个矩形构成的线段不相交，那么矩形一定不相交</p>
<p>同理可以投影到y轴上，如果两个投影中有任意一个不相交，那么矩形一定不相交，否则一定相交</p>
<p>同样的办法可以用在三维，四维甚至更高维的图形上</p>
<p>若线段相交，那么相交线段的左端点肯定是两线段左端点中坐标最小的，右端点肯定是两线段右端点中坐标最大的</p>
<p>这个结论也能推广到多个线段相交</p>
<p>同样，我们把矩形的投影到各个坐标轴上，得出相交线段，两条相交线段就分别是矩形的长和宽</p>
<p>这个结论也能用于高维图形上</p>
<p>所以本题虽简单，但很有启发意义，那些一味画图判断几种情况嵌套if的人这题相当于白做了，假设又遇到高维的，他们的嵌套if就会变得复杂，直到情况过多难以写出来的程度</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -&gt; int:</span><br><span class="line">        ret = (ay2 - ay1) * (ax2 - ax1) + (by2 - by1) * (bx2 - bx1)</span><br><span class="line">        if bx1 &gt; ax2 or ax1 &gt; bx2 or by1 &gt; ay2 or ay1 &gt; by2:</span><br><span class="line">            return ret</span><br><span class="line">        else:</span><br><span class="line">            return ret - (min(ax2, bx2) - max(ax1, bx1)) * (min(ay2, by2) - max(ay1, by1))</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-27"><a href="#2021-9-27" class="headerlink" title="2021.9.27"></a>2021.9.27</h1><p><em>今日天气：小雨/阴</em></p>
<p><em>如果你停止抱怨，不再追求你永远都得不到的东西，你就可以过上好日子</em></p>
<p align="right"><em>——丧钟为谁而鸣</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode639.解码方法 II</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>一条包含字母 A-Z 的消息通过以下的方式进行了编码：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p>
<p>要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，”11106” 可以映射为：</p>
<pre><code>&quot;AAJF&quot; 对应分组 (1 1 10 6)
&quot;KJF&quot; 对应分组 (11 10 6)
</code></pre><p>注意，像 (1 11 06) 这样的分组是无效的，因为 “06” 不可以映射为 ‘F’ ，因为 “6” 与 “06” 不同。</p>
<p>除了 上面描述的数字字母映射方案，编码消息中可能包含 ‘<em>‘ 字符，可以表示从 ‘1’ 到 ‘9’ 的任一数字（不包括 ‘0’）。例如，编码字符串 “1</em>“ 可以表示 “11”、”12”、”13”、”14”、”15”、”16”、”17”、”18” 或 “19” 中的任意一条消息。对 “1*” 进行解码，相当于解码该字符串可以表示的任何编码消息。</p>
<p>给你一个字符串 s ，由数字和 ‘*’ 字符组成，返回 解码 该字符串的方法 数目 。</p>
<p>由于答案数目可能非常大，返回对 109 + 7 取余 的结果。</p>
<p><strong><em>思路</em></strong></p>
<p>dp，在一个字符串s后面添加一个字符，有两种解码方法</p>
<p>1该字符单独作为一个字母解码，这样总解码方法在s的解码方法数基础上乘以该字符的解码方法数</p>
<p>2该字符和s的最后一个字符合并起来解码，这样总解码数需要在s去掉最后一个字符后的解码数上乘最后一个字符与该字符合并起来后的解码方法数</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDecodings(self, s: str) -&gt; int:</span><br><span class="line">        r = [1]</span><br><span class="line">        if s[0] == &apos;*&apos;:</span><br><span class="line">            r.append(9)</span><br><span class="line">        elif s[0] == &apos;0&apos;:</span><br><span class="line">            r.append(0)</span><br><span class="line">        else:</span><br><span class="line">            r.append(1)</span><br><span class="line">        </span><br><span class="line">        for i in range(1, len(s)):</span><br><span class="line">            if s[i - 1] == &apos;*&apos;:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    r.append(r[i - 1] * 15 + r[i] * 9)</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    r.append(r[i - 1] * 2)</span><br><span class="line">                elif s[i] in (&apos;7&apos;, &apos;8&apos;, &apos;9&apos;):</span><br><span class="line">                    r.append(r[i - 1] + r[i])</span><br><span class="line">                else:</span><br><span class="line">                    r.append(r[i - 1] * 2 + r[i])</span><br><span class="line">            elif s[i - 1] == &apos;1&apos;:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    r.append(r[i - 1] * 9 + r[i] * 9)</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    r.append(r[i - 1])</span><br><span class="line">                else:</span><br><span class="line">                    r.append(r[i - 1] + r[i])</span><br><span class="line">            elif s[i - 1] == &apos;2&apos;:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    r.append(r[i - 1] * 6 + r[i] * 9)</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    r.append(r[i - 1])</span><br><span class="line">                elif s[i] in (&apos;7&apos;, &apos;8&apos;, &apos;9&apos;):</span><br><span class="line">                    r.append(r[i])</span><br><span class="line">                else:</span><br><span class="line">                    r.append(r[i - 1] + r[i])</span><br><span class="line">            else:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    r.append(r[i] * 9)</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    r.append(0)</span><br><span class="line">                else:</span><br><span class="line">                    r.append(r[i])</span><br><span class="line">            r[i + 1] %= 1000000007</span><br><span class="line"></span><br><span class="line">        return r[len(s)]</span><br></pre></td></tr></table></figure>
<p><strong><em>改进</em></strong></p>
<p>经过我们思考分析，发现实际上r数组只用到了当前位置前两个，所以我们使用三个变量让他们原地计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDecodings(self, s: str) -&gt; int:</span><br><span class="line">        tr = 1</span><br><span class="line">        r = 9</span><br><span class="line">        if s[0] == &apos;*&apos;:</span><br><span class="line">            pass</span><br><span class="line">        elif s[0] == &apos;0&apos;:</span><br><span class="line">            r = 0</span><br><span class="line">        else:</span><br><span class="line">            r = 1</span><br><span class="line">        </span><br><span class="line">        for i in range(1, len(s)):</span><br><span class="line">            nr = 0</span><br><span class="line">            if s[i - 1] == &apos;*&apos;:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    nr = tr * 15 + r * 9</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    nr = tr * 2</span><br><span class="line">                elif s[i] in (&apos;7&apos;, &apos;8&apos;, &apos;9&apos;):</span><br><span class="line">                    nr = tr + r</span><br><span class="line">                else:</span><br><span class="line">                    nr = tr * 2 + r</span><br><span class="line">            elif s[i - 1] == &apos;1&apos;:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    nr = tr * 9 + r * 9</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    nr = tr</span><br><span class="line">                else:</span><br><span class="line">                    nr = tr + r</span><br><span class="line">            elif s[i - 1] == &apos;2&apos;:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    nr = tr * 6 + r * 9</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    nr = tr</span><br><span class="line">                elif s[i] in (&apos;7&apos;, &apos;8&apos;, &apos;9&apos;):</span><br><span class="line">                    nr = r</span><br><span class="line">                else:</span><br><span class="line">                    nr = tr + r</span><br><span class="line">            else:</span><br><span class="line">                if s[i] == &apos;*&apos;:</span><br><span class="line">                    nr = r * 9</span><br><span class="line">                elif s[i] == &apos;0&apos;:</span><br><span class="line">                    nr = 0</span><br><span class="line">                else:</span><br><span class="line">                    nr = r</span><br><span class="line">            tr = r</span><br><span class="line">            r = nr % 1000000007</span><br><span class="line"></span><br><span class="line">        return r</span><br></pre></td></tr></table></figure>
<p><strong><em>语法复习</em></strong></p>
<p>if a in (a, b, v, s):</p>
<p>这样的语句可以判断a是否在某个集合里</p>
<h1 id="2021-9-24"><a href="#2021-9-24" class="headerlink" title="2021.9.24"></a>2021.9.24</h1><p><em>今日天气：多云</em></p>
<p><em>基本粒子虽小，却构成了我们，宇宙虽大，我们却身处其中</em></p>
<p align="right"><em>——坍缩</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode430.扁平化多级双向链表</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p>
<p><strong><em>思路</em></strong></p>
<p>递归，遇到有子节点的，先扁平化子节点，然后把子节点连接在当前节点后，继续向后遍历</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, val, prev, next, child):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.next = next</span><br><span class="line">        self.child = child</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def flatten(self, head: &apos;Node&apos;) -&gt; &apos;Node&apos;:</span><br><span class="line">        p = head</span><br><span class="line">        while p != None:</span><br><span class="line">            if p.child == None:</span><br><span class="line">                p = p.next</span><br><span class="line">            else:</span><br><span class="line">                q = self.flatten(p.child)</span><br><span class="line">                p.child = None</span><br><span class="line">                np = p.next</span><br><span class="line">                p.next = q</span><br><span class="line">                q.prev = p</span><br><span class="line">                while q.next != None:</span><br><span class="line">                    q = q.next</span><br><span class="line">                q.next = np</span><br><span class="line">                if np != None:</span><br><span class="line">                    np.prev = q</span><br><span class="line">                p = np</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-23"><a href="#2021-9-23" class="headerlink" title="2021.9.23"></a>2021.9.23</h1><p><em>今日天气：晴</em></p>
<p><em>宇宙本身就是疯狂而混乱的</em></p>
<p align="right"><em>——Rick and Morty</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode326.3的幂</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>判断一个整数是否是3的幂</p>
<p><strong><em>思路</em></strong></p>
<p>直接暴力循环除以3，注意负数和0</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPowerOfThree(self, n: int) -&gt; bool:</span><br><span class="line">        flag = True</span><br><span class="line">        if n &lt;= 0:</span><br><span class="line">            return False</span><br><span class="line">        while True:</span><br><span class="line">            if n == 1:</span><br><span class="line">                break</span><br><span class="line">            elif n % 3 != 0:</span><br><span class="line">                flag = False</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                n /= 3</span><br><span class="line">        return flag</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-22"><a href="#2021-9-22" class="headerlink" title="2021.9.22"></a>2021.9.22</h1><p><em>今日天气：多云</em></p>
<p><em>过去就像攥在手中的干沙，自以为攥得很紧，实际早已从指缝流光了，记忆是一条干涸的河流，只在毫无生气的河床中剩下零落的砾石</em></p>
<p align="right"><em>——三体·地球往事</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode725.分割链表</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p>
<p>这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p>
<p>返回一个由上述 k 部分组成的数组。</p>
<p><strong><em>思路</em></strong></p>
<p>很简单，也是暴力题</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val=0, next=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.next = next</span><br><span class="line">class Solution:</span><br><span class="line">    def splitListToParts(self, head: ListNode, k: int) -&gt; List[ListNode]:</span><br><span class="line">        l = 0</span><br><span class="line">        p = head</span><br><span class="line">        while p != None:</span><br><span class="line">            p = p.next</span><br><span class="line">            l += 1</span><br><span class="line">        base = l // k</span><br><span class="line">        time = l - k * base</span><br><span class="line">        p = head</span><br><span class="line">        ret = []</span><br><span class="line">        for i in range(time):</span><br><span class="line">            lkd = ListNode(val = p.val)</span><br><span class="line">            hlkd = lkd</span><br><span class="line">            p = p.next</span><br><span class="line">            for j in range(base):</span><br><span class="line">                nlkd = ListNode(val = p.val)</span><br><span class="line">                p = p.next</span><br><span class="line">                lkd.next = nlkd</span><br><span class="line">                lkd = nlkd</span><br><span class="line">            ret.append(hlkd)</span><br><span class="line">        for i in range(time, k):</span><br><span class="line">            if base == 0:</span><br><span class="line">                ret.append(None)</span><br><span class="line">            else:</span><br><span class="line">                lkd = ListNode(val = p.val)</span><br><span class="line">                hlkd = lkd</span><br><span class="line">                p = p.next</span><br><span class="line">                for j in range(base - 1):</span><br><span class="line">                    nlkd = ListNode(val = p.val)</span><br><span class="line">                    p = p.next</span><br><span class="line">                    lkd.next = nlkd</span><br><span class="line">                    lkd = nlkd</span><br><span class="line">                ret.append(hlkd)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><strong><em>语法复习</em></strong></p>
<p>None表示空对象</p>
<h1 id="2021-9-21"><a href="#2021-9-21" class="headerlink" title="2021.9.21"></a>2021.9.21</h1><p><em>今日天气：多云/风</em></p>
<p><em>活着本身就是一种幸运</em></p>
<p align="right"><em>——三体·死神永生</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode58.最后一个单词的长度</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。</p>
<p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<p><strong><em>思路</em></strong></p>
<p>暴力即可</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        flag = False</span><br><span class="line">        ret = 0</span><br><span class="line">        for i in range(len(s) - 1, -1, -1):</span><br><span class="line">            if s[i] != &apos; &apos;:</span><br><span class="line">                if flag:</span><br><span class="line">                    ret += 1</span><br><span class="line">                else:</span><br><span class="line">                    flag = True</span><br><span class="line">                    ret += 1</span><br><span class="line">            else:</span><br><span class="line">                if flag:</span><br><span class="line">                    break</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-20"><a href="#2021-9-20" class="headerlink" title="2021.9.20"></a>2021.9.20</h1><p><em>今日天气：大雨转阴</em></p>
<p><em>寒风造就了维京勇士</em></p>
<p align="right"><em>——JOJO的奇妙冒险·幻影之血</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode673.最长递增子序列的个数</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p><strong><em>思路</em></strong></p>
<p>最长递增子序列使用dp，dp的同时更新个数，统计出长度后再统计个数之和</p>
<p>这题有更简单的做法，但我没想</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findNumberOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">        dplen = [[], [nums[0]]]</span><br><span class="line">        dptime = [[], [1]]</span><br><span class="line">        for i in range(1, len(nums)):</span><br><span class="line">            l = nums[i]</span><br><span class="line">            t = 1</span><br><span class="line">            for j in range(len(dplen) - 1, -1, -1):</span><br><span class="line">                if dplen[j][-1] &lt; nums[i]:</span><br><span class="line">                    </span><br><span class="line">            dplen.append(l)</span><br><span class="line">            dptime.append(t)</span><br><span class="line"></span><br><span class="line">        maxl = 0</span><br><span class="line">        maxt = 0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if dplen[i] &gt; maxl:</span><br><span class="line">                maxl = dplen[i]</span><br><span class="line">                maxt = dptime[i]</span><br><span class="line">            elif dplen[i] == maxl:</span><br><span class="line">                maxt += dptime[i]</span><br><span class="line">        </span><br><span class="line">        return maxt</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-19"><a href="#2021-9-19" class="headerlink" title="2021.9.19"></a>2021.9.19</h1><p><em>今日天气：晴</em></p>
<p><em>所谓的觉悟，并非牺牲的意念</em></p>
<p><em>而是在黑暗的荒野中，开辟出一条理应前进的光明大道！</em></p>
<p align="right"><em>——JOJO的奇妙冒险·黄金之风</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode650.只有两个键的键盘</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>最初记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作：</p>
<pre><code>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
Paste（粘贴）：粘贴 上一次 复制的字符。
</code></pre><p>给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 ‘A’ 。返回能够打印出 n 个 ‘A’ 的最少操作次数。</p>
<p><strong><em>思路</em></strong></p>
<p>分解质因数</p>
<p>如果最终的目标数有因子，那么我们一定可以凑出这个因子，然后复制若干次</p>
<p>假设最终要得到30个A，30有一对因子5和6，为此我们凑出6，再复制5次得到30个</p>
<p>6有因子2和3，为此我们凑出2，再复制3次得到6个，</p>
<p>那么我们可以先得到复制2次得到2个A</p>
<p>因此答案就是数n所有质因数的和</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minSteps(self, n: int) -&gt; int:</span><br><span class="line">        i = 2</span><br><span class="line">        ret = 0</span><br><span class="line">        while i &lt;= n:</span><br><span class="line">            if n % i == 0:</span><br><span class="line">                n /= i</span><br><span class="line">                ret += i</span><br><span class="line">            else:</span><br><span class="line">                i += 1</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-18"><a href="#2021-9-18" class="headerlink" title="2021.9.18"></a>2021.9.18</h1><p><em>今日天气：晴</em></p>
<p><em>瞬间啊，我们是活在瞬间的生物啊！</em></p>
<p align="right"><em>——日常</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode292.Nim 游戏</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>你和你的朋友，两个人一起玩 Nim 游戏：</p>
<pre><code>桌子上有一堆石头。
你们轮流进行自己的回合，你作为先手。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
</code></pre><p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p>
<p><strong><em>思路</em></strong></p>
<p>经典Nim，直接返回模4是否为0</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canWinNim(self, n: int) -&gt; bool:</span><br><span class="line">        return n % 4 != 0</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-17"><a href="#2021-9-17" class="headerlink" title="2021.9.17"></a>2021.9.17</h1><p><em>今日天气：多云</em></p>
<p><em>飞蛾并不觉得阴暗，它至少享受了短暂的光明</em></p>
<p align="right"><em>——朝闻道</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode36.有效的数独</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<pre><code>数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
</code></pre><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p><strong><em>思路</em></strong></p>
<p>暴力，先检查每行，设置容量为9的数组，遇到一个数字就标记，若该数字之前标记过，则数独不合法</p>
<p>同样的方法检查每一列，每个九宫格</p>
<p>还有更快的方法，直接设立每列，每行，每九宫格的数字出现标记，一次遍历就检查完，但我一时间没想到，写博客的时候突然想到的</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">class Solution:</span><br><span class="line">    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:</span><br><span class="line">        flag = True;</span><br><span class="line"></span><br><span class="line">        for i in range(9):</span><br><span class="line">            flags = numpy.zeros(9, bool)</span><br><span class="line">            for j in range(9):</span><br><span class="line">                if board[i][j] == &quot;.&quot;:</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    num = int(board[i][j])</span><br><span class="line">                    if flags[num - 1]:</span><br><span class="line">                        flag = False</span><br><span class="line">                        break</span><br><span class="line">                    else:</span><br><span class="line">                        flags[num - 1] = True</span><br><span class="line">            if not flag:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for i in range(9):</span><br><span class="line">            flags = numpy.zeros(9, bool)</span><br><span class="line">            for j in range(9):</span><br><span class="line">                if board[j][i] == &quot;.&quot;:</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    num = int(board[j][i])</span><br><span class="line">                    if flags[num - 1]:</span><br><span class="line">                        flag = False</span><br><span class="line">                        break</span><br><span class="line">                    else:</span><br><span class="line">                        flags[num - 1] = True</span><br><span class="line">            if not flag:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        for xi in range(3):</span><br><span class="line">            x = 3 * xi</span><br><span class="line">            for yi in range(3):</span><br><span class="line">                y = 3 * yi</span><br><span class="line">                flags = numpy.zeros(9, bool)</span><br><span class="line">                for i in range(3):</span><br><span class="line">                    for j in range(3):</span><br><span class="line">                        if board[x + i][y + j] == &quot;.&quot;:</span><br><span class="line">                            continue</span><br><span class="line">                        else:</span><br><span class="line">                            num = int(board[x + i][y + j])</span><br><span class="line">                            if flags[num - 1]:</span><br><span class="line">                                flag = False</span><br><span class="line">                                break</span><br><span class="line">                            else:</span><br><span class="line">                                flags[num - 1] = True</span><br><span class="line">        </span><br><span class="line">        return flag</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-16"><a href="#2021-9-16" class="headerlink" title="2021.9.16"></a>2021.9.16</h1><p><em>今日天气：多云</em></p>
<p><em>在疯狂面前，理智是软弱无力的</em></p>
<p align="right"><em>——三体·地球往事</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode212.单词搜索 II</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p><strong><em>数据范围</em></strong></p>
<p>1 &lt;= m, n &lt;= 12，words列表长度3e4，每个单词长度不超过10</p>
<p><strong><em>思路</em></strong></p>
<p>本题不能直接暴力搜索，暴力的话，起点数12 * 12，每个点做四次判断，4 ^ 10约为1e6，再加上每个字符串都需要搜索一次，3e4 * 12 * 12 * 4 ^ 10，总体运算次数已经不能承受了</p>
<p>采取构造字典树的办法，构造字典树的复杂度只有12 * 12 * 4 ^ 10约为1e8，每次查找字典树的复杂度是10，总计查找复杂度约为3e5</p>
<p><strong><em>解决</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">class Solution:</span><br><span class="line">    def findAllWrods(self, visit, board, x, y, n, m, tire, totlist, p, times):</span><br><span class="line">        nxt = ord(board[x][y]) - ord(&apos;a&apos;) </span><br><span class="line">        visit[x][y] = 1</span><br><span class="line">        </span><br><span class="line">        if tire[p][nxt] == 0:</span><br><span class="line">            tire[p][nxt] = totlist[0]</span><br><span class="line">            totlist[0] += 1</span><br><span class="line">        p = tire[p][nxt]</span><br><span class="line"></span><br><span class="line">        #print(&quot;%d %d %s&quot; %(x, y, board[x][y]))</span><br><span class="line"></span><br><span class="line">        times -= 1</span><br><span class="line">        if times == 0:</span><br><span class="line">            visit[x][y] = 0</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        if x + 1 &lt; n and visit[x + 1][y] == 0:</span><br><span class="line">            self.findAllWrods(visit, board, x + 1, y, n, m, tire, totlist, p, times)</span><br><span class="line">        if y + 1 &lt; m and visit[x][y + 1] == 0:</span><br><span class="line">            self.findAllWrods(visit, board, x, y + 1, n, m, tire, totlist, p, times)</span><br><span class="line">        if x - 1 &gt; -1 and visit[x - 1][y] == 0:</span><br><span class="line">            self.findAllWrods(visit, board, x - 1, y, n, m, tire, totlist, p, times)</span><br><span class="line">        if y - 1 &gt; -1 and visit[x][y - 1] == 0:</span><br><span class="line">            self.findAllWrods(visit, board, x, y - 1, n, m, tire, totlist, p, times)</span><br><span class="line">        visit[x][y] = 0</span><br><span class="line"></span><br><span class="line">    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:</span><br><span class="line">        totlist = [1]</span><br><span class="line">        tire = numpy.zeros((100000, 26), int)</span><br><span class="line">        </span><br><span class="line">        n = len(board)</span><br><span class="line">        m = len(board[0])</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(m):</span><br><span class="line">                visit = numpy.zeros((n, m))</span><br><span class="line">                #print(i, j)</span><br><span class="line">                self.findAllWrods(visit, board, i, j, n, m, tire, totlist, 0, 10)</span><br><span class="line">            </span><br><span class="line">        ret = []</span><br><span class="line">        for word in words:</span><br><span class="line">            p = 0</span><br><span class="line">            flag = True</span><br><span class="line">            for cha in word:</span><br><span class="line">                nxt = ord(cha) - ord(&apos;a&apos;)</span><br><span class="line">                if tire[p][nxt] == 0:</span><br><span class="line">                    flag = False</span><br><span class="line">                    break</span><br><span class="line">                p = tire[p][nxt]</span><br><span class="line">            if flag:</span><br><span class="line">                ret.append(word)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<p><strong><em>语法复习</em></strong></p>
<p>1.参数传递方式</p>
<p>python中，字典，列表，元组参数都是可以在函数内部修改其值的，修改之后会影响到函数外，而数字，布尔等参数无法在函数内部修改其值，修改后不会影响函数外</p>
<p>python中无法像c++一样传递引用</p>
<h1 id="2021-9-15"><a href="#2021-9-15" class="headerlink" title="2021.9.15"></a>2021.9.15</h1><p><em>今日天气：晴</em></p>
<p><em>“What is my purpose？”</em></p>
<p><em>“You pass butter”</em></p>
<p align="right"><em>——Rick &amp; Morty</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode162.寻找峰值</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<p><strong><em>数据范围</em></strong></p>
<p>数组长度不超过1000，暴力可做，但本题要求nlogn</p>
<p><strong><em>思路</em></strong></p>
<p>知道是二分，但不知道怎么二分，于是参考了思路，原来是随便比较两个数，峰值一定在偏大的那一侧，不得不说把两端设定为低谷实在是妙了</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findPeakElement(self, nums: List[int]) -&gt; int:</span><br><span class="line">        l = 0</span><br><span class="line">        h = len(nums) - 1</span><br><span class="line">        m = (l + h) &gt;&gt; 1</span><br><span class="line">        while l &lt; h:</span><br><span class="line">            if nums[m] &lt; nums[m + 1]:</span><br><span class="line">                l = m + 1</span><br><span class="line">            else:</span><br><span class="line">                h = m</span><br><span class="line">            m = (l + h) &gt;&gt; 1</span><br><span class="line">        return m</span><br></pre></td></tr></table></figure></p>
<h1 id="2021-9-14"><a href="#2021-9-14" class="headerlink" title="2021.9.14"></a>2021.9.14</h1><p><em>今日天气：晴</em></p>
<p><em>没有了对高处的恐惧就体会不到高处之美</em></p>
<p align="right"><em>——三体·黑暗森林</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode524.通过删除字母匹配到字典里最长单词</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。</p>
<p>如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p><strong><em>数据范围</em></strong></p>
<p>s的长度，字典长度，字典中每字符串的长度都不会超过1000</p>
<p><strong><em>思路</em></strong></p>
<p>字符串子串的匹配只需要O(n + m)，忘记了，这题只需要直接暴力就行了</p>
<p>当时写了一个字典树</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def adapt(self, s, words):</span><br><span class="line">        j = 0</span><br><span class="line">        flag = False</span><br><span class="line">        for i in range(len(words)):</span><br><span class="line">            while j &lt; len(s) and s[j] != words[i]:</span><br><span class="line">                j += 1</span><br><span class="line">            if j == len(s):</span><br><span class="line">                flag = True</span><br><span class="line">                break</span><br><span class="line">            j += 1</span><br><span class="line"></span><br><span class="line">        if flag:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        else:</span><br><span class="line">            return words</span><br><span class="line"></span><br><span class="line">    def cmp(self, s1, s2):</span><br><span class="line">        if len(s1) &gt; len(s2):</span><br><span class="line">            return True</span><br><span class="line">        elif len(s1) &lt; len(s2):</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return s1 &lt; s2</span><br><span class="line"></span><br><span class="line">    def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str:</span><br><span class="line">        ret = &quot;&quot;</span><br><span class="line">        for words in dictionary:</span><br><span class="line">            temp = self.adapt(s, words)</span><br><span class="line">            if self.cmp(temp, ret):</span><br><span class="line">                ret = temp</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>1.数组初始化</p>
<p>可以使用numpy库，调用numpy.zeros()方法来得到一个多维全0数组</p>
<p><strong><em>知识点复习</em></strong></p>
<p>1.字典树</p>
<p>字典树可以满足在一堆字符串中快速查找一个字符串的要求，其查找的复杂度不会超过被查找字符串的长度</p>
<p>建立方法：</p>
<p>首先建立一个节点数组，第一维是节点个数，等于字典中字符串长度×字符串数目，第二维是符号数，比如字符串中只有小写字母，那么第二维大小就是26</p>
<p>建立节点计数器tot，令其初值为1</p>
<p>遍历字典中的每一个字符串，每遇到一个新的字符串，设立一个指针为p，初始值为0即指向字典树的根节点，根据字符串的每个字符来挪动指针，比如当前字符为a，a是第0个字符，那么查看p指向的当前节点的下标为0的指针是否有值，若有，p移动过去，若没有，在tot处建立新节点，并使指针指向它，然后p移动过去</p>
<p>查找时，只需要按照同样的方法挪动指针，只不过遇到指针没有指向的，不再建立新节点而是直接返回查找失败</p>
<p>照这种方法，假设我们有catch在字典中，那么cat也可以查找成功，这显然不是我们想要的，所以，我们还需要建立ed数组对应每个节点，若该节点是某个字符串的结尾，我们就在ed数组里面加一个标记</p>
<h1 id="2021-9-13"><a href="#2021-9-13" class="headerlink" title="2021.9.13"></a>2021.9.13</h1><p><em>今日天气：晴</em></p>
<p><em>无言是最大的轻蔑</em></p>
<p align="right"><em>——三体·黑暗森林</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode447.回旋镖的数量</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。</p>
<p>返回平面上所有回旋镖的数量。</p>
<p><strong><em>数据范围</em></strong></p>
<p>总计不到500个点</p>
<p>每个点坐标绝对值不大于1000</p>
<p><strong><em>思路</em></strong></p>
<p>这题数据比较弱，但直接暴力也肯定不行，但我们可以先顺着暴力的思路想：</p>
<p>首先，每个点都可以做中间的点，对每个点都求出它到其它点的距离</p>
<p>求出这些距离后，放入数组，找到相等的距离，计算出回旋镖数</p>
<p>找相等的距离可以使用排序后再遍历的方式</p>
<p>这样整个复杂度就是n²logn</p>
<p>看了题解，有很多人使用的是哈希表，复杂度会降到n²</p>
<p>哈希表还是弱项啊</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numberOfBoomerangs(self, points: List[List[int]]) -&gt; int:</span><br><span class="line">        ret = 0</span><br><span class="line">        for i in points:</span><br><span class="line">            d = []</span><br><span class="line">            for j in points:</span><br><span class="line">                dist = (i[0] - j[0]) ** 2 + (i[1] - j[1]) ** 2</span><br><span class="line">                d.append(dist)</span><br><span class="line">            d.sort()</span><br><span class="line">            seqtime = 1</span><br><span class="line">            for j in range(1, len(d)):</span><br><span class="line">                if d[j] == d[j - 1]:</span><br><span class="line">                    seqtime += 1</span><br><span class="line">                else:</span><br><span class="line">                    if seqtime == 1:</span><br><span class="line">                        continue</span><br><span class="line">                    ret += seqtime * (seqtime - 1)</span><br><span class="line">                    seqtime = 1</span><br><span class="line">            if seqtime != 1:</span><br><span class="line">                ret += seqtime * (seqtime - 1)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure></p>
<h1 id="2021-9-12"><a href="#2021-9-12" class="headerlink" title="2021.9.12"></a>2021.9.12</h1><p><em>今日天气：晴</em></p>
<p><em>弱小和无知从来都不是生存的障碍，傲慢才是</em></p>
<p align="right"><em>——三体·死神永生</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode678.有效的括号字符串</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<pre><code>任何左括号 ( 必须有相应的右括号 )。
任何右括号 ) 必须有相应的左括号 ( 。
左括号 ( 必须在对应的右括号之前 )。
* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
一个空字符串也被视为有效字符串。
</code></pre><p><strong><em>数据范围</em></strong></p>
<p>字符串长度为100以内</p>
<p><strong><em>思路</em></strong></p>
<p>看到这题就觉得是文法判断，一直想着怎么用自动机，仔细分析下发现这是个上下文有关文法，傻眼了</p>
<p>看了一眼提示才明白过来没那么难，分析下规律用贪心法就能做了</p>
<p>先不考虑星号，假设只有左右括号，我们可以推出来的关于合法字符串的结论：</p>
<p>1.任何一个前缀中，左括号数只可能比右括号数多</p>
<p>2.最终的字符串中左右括号一样多</p>
<p>那么我们可以记录一个数，每遇到一次右括号就减一，遇到左括号就加一，如果中间某个地方这个数变成了负数，我们认为这个字符串不合法，或者最终这个数不为0，我们也认为这个字符串不合法</p>
<p>那么，加入星号之后，我们就用贪心法，每次都尽量把星号当成一个右括号，这样，遇到星号时，我们上面记录的这个数也会减一，同时，我们记录一下星号数，这时，每遇到一个星号，我们把这个数目加2，至于为什么加2不加1，我们后面讲</p>
<p>那么，如果我们配对着配对着，发现左括号数不够了怎么办，我们就把原来看做右括号的星号，变回单纯的星号，如果还不够，再把星号变成左括号，即当左括号数为0，我们遇到一个右括号，就把星号数减一，这样就是为什么我们一开始统计星号数目时每次加2的原因，因为星号相当于可以变换两次</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def checkValidString(self, s: str) -&gt; bool:</span><br><span class="line">        l_para = 0</span><br><span class="line">        star = 0</span><br><span class="line">        for i in s:</span><br><span class="line">            if i == &apos;(&apos;:</span><br><span class="line">                l_para += 1</span><br><span class="line">            elif i == &apos;*&apos;:</span><br><span class="line">                if l_para &gt; 0:</span><br><span class="line">                    l_para -= 1</span><br><span class="line">                    star += 2</span><br><span class="line">                else:</span><br><span class="line">                    star += 1</span><br><span class="line">            else:</span><br><span class="line">                if l_para &gt; 0:</span><br><span class="line">                    l_para -= 1</span><br><span class="line">                else:</span><br><span class="line">                    if star &gt; 0:</span><br><span class="line">                        star -= 1</span><br><span class="line">                    else:</span><br><span class="line">                        return False</span><br><span class="line">        </span><br><span class="line">        if l_para == 0:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure></p>
<h1 id="2021-9-11"><a href="#2021-9-11" class="headerlink" title="2021.9.11"></a>2021.9.11</h1><p><em>今日天气：晴</em></p>
<p><em>“你父亲在回忆这件事后，对我发出这样的感叹：在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了”</em></p>
<p align="right"><em>——三体·地球往事</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode600.不含连续1的非负整数</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。</p>
<p><strong><em>数据范围</em></strong></p>
<p>n最多1e9</p>
<p><strong><em>思路</em></strong></p>
<p>统计一个数n的二进制是否有连续1没有太好的方法，直接暴力的复杂度是log(n)，从1到n总计nlog(n)的复杂度对于1e9的规模来说肯定是不能接受的</p>
<p>那么我们另辟蹊径，寻找规律</p>
<p>设f(n)是我们要找的答案</p>
<p>我们不妨先找n的二进制为一连串1的数，比如3，7，15，找到f(n)的规律</p>
<p>为什么从这样的数开始找呢？因为具有代表性，比如3的二进制是两个1，那么f(3)就代表了所有二进制数位小于等于2的满足要求的数</p>
<p>那么，我们不妨设g(2) = f(3)，因为f(3)代表了所有二进制数位小于等于2的满足要求的数，以此类推g(3) = f(7)， g(4) = f(15)</p>
<p>下面就找f(15)</p>
<p>接下来，我们应该如何入手呢？15的二进制是四位数，四个1，我们如果把所有小于15的数分成两类，一类是四位数，另一类不是，那么不是四位数的一类肯定数位小于等于3位，就是g(3) = f(7)</p>
<p>那么满足要求的四位数的个数怎么求？我们试着构建一下，满足四位数，最高位是1，那么第三位肯定是0，这时候我们发现，可以自由选择的就是剩下的几位，剩下两位，个数为g(2) = f(3)</p>
<p>根据上面的推理，找到g的递推公式g(n) = g(n - 1) + g(n - 2)</p>
<p>g是一个斐波那契数列，我们找到最初两项g(0) = 1， g(1) = 2</p>
<p>接下来，我们把结论从二进制全1的数推到任意数，我们知道，对于任意正数n，其二进制最高位一定是1，假设n是l位二进制数，那么小于它的数又可以分成两种：</p>
<p>1.数位小于l的</p>
<p>2.数位等于l的</p>
<p>对于情况1，显然符合要求的数为g(l-1)</p>
<p>对于情况2呢？显然这些数的第l位都是1，那么第l-1位一定是0，那能不能说符合要求的数一定是g(l-2)呢？</p>
<p>可以看一个样例10010（十进制为18），对这个数来说，小于它的5位二进制数只有10000，10001两个，原因是我们确定前两位为10，后面三位并不会像我们之前推导类似11111这样的数时，是可以任意挑选的，而是只能在小于后三位010的基础上挑选</p>
<p>但如果n最高，次高位都是1，我们显然后几位就可以随意挑选了，这时候就是g(l-2)</p>
<p>所以，情况2的个数要再分两种情况：</p>
<p>2.1.若n首两位为10，则去掉n的最高位得到数t，f(t)即为情况2的结果，换句话说假设n为l位，则为f(n-1000……0)（l-1个0）</p>
<p>2.2.若n首两位为11，则情况2的结果为g(l-2)</p>
<p>得到了上面的思路，我们果断写了一份代码，结果超时了，为什么呢？因为斐波那契数列的实现方式有问题，我们使用的是递归实现return g(n - 1) + g(n - 2)这样在n非常大的时候时间复杂度就会指数级增长，因此，我们改用数组存储这个数列前100个的值，需要的时候直接取用</p>
<p>或许也可以使用非常装逼的矩阵快速幂来实现斐波那契数列，但没必要</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def init(self):</span><br><span class="line">        ret = []</span><br><span class="line">        ret.append(1)</span><br><span class="line">        ret.append(2)</span><br><span class="line">        ret.append(3)</span><br><span class="line">        for i in range(3, 100):</span><br><span class="line">            ret.append(ret[i - 1] + ret[i - 2])</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">    def f(self, n, num_of_0xf):</span><br><span class="line">        if n == 0:</span><br><span class="line">            return 1</span><br><span class="line">        </span><br><span class="line">        i = 1</span><br><span class="line">        s = 1</span><br><span class="line">        while i &lt; n:</span><br><span class="line">            i &lt;&lt;= 1</span><br><span class="line">            i += 1</span><br><span class="line">            s += 1</span><br><span class="line">            #print(&quot;i = %x s = %d&quot; % (i, s))</span><br><span class="line"></span><br><span class="line">        if i == n:</span><br><span class="line">            return num_of_0xf[s]</span><br><span class="line">        else:</span><br><span class="line">            s -= 1</span><br><span class="line">            mask = 1</span><br><span class="line">            mask &lt;&lt;= s</span><br><span class="line">            i &gt;&gt;= 1</span><br><span class="line">            #print(&quot;mask = %x, i = %x, s = %d&quot; % (mask, i, s))</span><br><span class="line">            n ^= mask</span><br><span class="line">            #print(n)</span><br><span class="line">            mask &gt;&gt;= 1</span><br><span class="line">            t1 = num_of_0xf[s]</span><br><span class="line">            t2 = 0</span><br><span class="line">            if n &amp; mask == 0:</span><br><span class="line">                t2 = self.findIntegers(n)</span><br><span class="line">            else:</span><br><span class="line">                t2 = num_of_0xf[s - 1]</span><br><span class="line">            #print(t1)</span><br><span class="line">            return t1 + t2</span><br><span class="line"></span><br><span class="line">    def findIntegers(self, n: int) -&gt; int:</span><br><span class="line">        num_of_0xf = self.init()</span><br><span class="line">        return self.f(n, num_of_0xf)</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>1.python的位运算</p>
<p>与C++的算符基本一致，若想要输出二进制，可以使用bin()函数</p>
<h1 id="2021-9-10"><a href="#2021-9-10" class="headerlink" title="2021.9.10"></a>2021.9.10</h1><p><em>今日天气：晴</em></p>
<p><em>“人类的伟大就在于面对恐惧时的崇高姿态”</em></p>
<p align="right"><em>——JOJO的奇妙冒险·战斗潮流</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode1894.找到需要补充粉笔的学生编号</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。</p>
<p>给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。</p>
<p>请你返回需要 补充 粉笔的学生 编号 。</p>
<p><strong><em>思路</em></strong></p>
<p>这题标了中等难度，但这题不过是个简单暴力题而已</p>
<p>先统计一轮下来需要的粉笔数，然后取余，再从头到尾遍历找到需要补充的学生编号即可</p>
<p>不得不吐槽一句，leetcode的题难度标的实在太随意了，有时候太简单，这样的题也能标中等难度，有时候又太难，上次一个线段树居然标了简单，我愣是一时没想出来</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def chalkReplacer(self, chalk: List[int], k: int) -&gt; int:</span><br><span class="line">        total = 0</span><br><span class="line">        for i in chalk:</span><br><span class="line">            total += i</span><br><span class="line">        </span><br><span class="line">        k %= total</span><br><span class="line">        for i in range(len(chalk)):</span><br><span class="line">            if k &lt; chalk[i]:</span><br><span class="line">                return i</span><br><span class="line">            else:</span><br><span class="line">                k -= chalk[i]</span><br></pre></td></tr></table></figure></p>
<h1 id="2021-9-9"><a href="#2021-9-9" class="headerlink" title="2021.9.9"></a>2021.9.9</h1><p><em>今日天气：多云</em></p>
<p><em>“不知道会发生什么，这才是生活”</em></p>
<p align="right"><em>——日常</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode68.文本左右对齐</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p>
<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ‘ ‘ 填充，使得每行恰好有 maxWidth 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p>
<p>说明:</p>
<pre><code>单词是指由非空格字符组成的字符序列。
每个单词的长度大于 0，小于等于 maxWidth。
输入单词数组 words 至少包含一个单词。
</code></pre><p><strong><em>思路</em></strong></p>
<p>这题标了困难，但其实我觉得这种题只是繁琐，算不上困难，在大三上学期我练习准备CSP考试的时候，我曾经做了不少这样的题，什么字符串分割，markdown语法渲染等等。破这种题的诀窍就是自顶而下，逐步求精，不要事无巨细地从头模拟到尾，一个函数写下来，那样铁失败，铁难调bug</p>
<p>先看懂规则，这题就是把单词放在宽度有限的行里，大体分三种情况：</p>
<p>1.本行就一个单词，那么单词左对齐，后面空格补齐</p>
<p>2.本行是结尾行，单词左对齐，单词间有一个空格，后面空格补齐</p>
<p>3.除1，2外的情况，第一个单词左对齐，最后一个右对齐，平均分配空格，若除不开，则左边多分配一点</p>
<p>所以，关键就是看清本行是哪种情况，这里我们先实现一个函数，让这个函数能够判断本行能装下几个单词</p>
<p>有了这个函数之后，我们再考虑三种情况的区分和具体的渲染怎么做</p>
<p>情况1：判断当前单词+当前行单词数是否为总单词数</p>
<p>渲染方法：遍历输出当前单词+空格隔开，最后空格补齐</p>
<p>情况2：不是情况1，并判断当前单词数是否为1</p>
<p>渲染方法：直接当前单词+空格补齐</p>
<p>情况3：直接写else</p>
<p>渲染方法：先算出空格数除以单词间隔数的余数x和商y，在第1到x个单词之间，输出y+1个空格，之后输出y个空格</p>
<p>这样，我们的思路清晰，代码层次强，定位bug也迅速</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def how_many_words(self, words, cur, maxWidth):</span><br><span class="line">        i = cur</span><br><span class="line">        num = 0</span><br><span class="line">        last = maxWidth</span><br><span class="line">        while i &lt; len(words):</span><br><span class="line">            if last - num &lt; len(words[i]):</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                last -= len(words[i])</span><br><span class="line">                num += 1</span><br><span class="line">                i += 1</span><br><span class="line">        return num, last</span><br><span class="line"></span><br><span class="line">    def fullJustify(self, words: List[str], maxWidth: int) -&gt; List[str]:</span><br><span class="line">        i = 0</span><br><span class="line">        ret = []</span><br><span class="line">        </span><br><span class="line">        while True:</span><br><span class="line">            num, last = self.how_many_words(words, i, maxWidth)</span><br><span class="line">            #print(&quot;num = %d, last = %d&quot; % (num, last))</span><br><span class="line">            i += num</span><br><span class="line">            temp = &quot;&quot;</span><br><span class="line">            if i == len(words):</span><br><span class="line">                for j in range(num - 1):</span><br><span class="line">                    temp += words[i - num + j]</span><br><span class="line">                    temp += &quot; &quot;</span><br><span class="line">                    #print(temp)</span><br><span class="line">                temp += words[i - 1]</span><br><span class="line">                temp += (&quot; &quot; * (last - num + 1))</span><br><span class="line">                #print(temp)</span><br><span class="line">                ret.append(temp)</span><br><span class="line">                break</span><br><span class="line">            elif num == 1:</span><br><span class="line">                temp += words[i - 1]</span><br><span class="line">                temp += (&quot; &quot; * (last - num + 1))</span><br><span class="line">                #print(temp)</span><br><span class="line">                ret.append(temp)</span><br><span class="line">            else:</span><br><span class="line">                base = last // (num - 1)</span><br><span class="line">                eta = last % (num - 1)</span><br><span class="line">                for j in range(0, eta):</span><br><span class="line">                    temp += words[i - num + j]</span><br><span class="line">                    temp += (&quot; &quot; * (base + 1))</span><br><span class="line">                    #print(temp)</span><br><span class="line">                for j in range(eta, num - 1):</span><br><span class="line">                    temp += words[i - num + j]</span><br><span class="line">                    temp += (&quot; &quot; * base)</span><br><span class="line">                    #print(temp)</span><br><span class="line">                temp += words[i - 1]</span><br><span class="line">                #print(temp)</span><br><span class="line">                ret.append(temp)</span><br><span class="line"></span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>1.python不换行输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(str, end=&quot;&quot;) # 表示输出str后，尾部什么都不加</span><br></pre></td></tr></table></figure>
<p>2.函数多个返回值</p>
<p>直接返回元组即可，接收时也可以使用元组接收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def func()</span><br><span class="line">	return x, y</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">x, y = func()</span><br></pre></td></tr></table></figure>
<h1 id="2021-9-8"><a href="#2021-9-8" class="headerlink" title="2021.9.8"></a>2021.9.8</h1><p><em>今日天气：乌云</em></p>
<p><em>“爱而得其人，乃最佳；爱而失其人，次佳”</em></p>
<p align="right"><em>——JOJO的奇妙冒险·幻影之血</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode502.IPO</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。</p>
<p>给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。</p>
<p>最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>
<p>总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。</p>
<p>答案保证在 32 位有符号整数范围内。</p>
<p><strong><em>思路</em></strong></p>
<p>这是一道贪心题目，显然在成本足够的情况下的时候，我们选的项目肯定是利润越高越好。而且，我们显然是不会选择负利润的项目的，这样我们的资本肯定会越来越多</p>
<p>这样的话，我们可以把当前可以选择的项目的利润，存在一个优先队列里，每次从队列里面取出利润最高的一项来完成之，这会导致我们的资本增加，以至于我们能够接到更多的项目，我们进一步把这样的项目来进入优先队列里。为了让我们能够更快捷地知道能够接到哪些项目，我们按照项目成本从小到大排序</p>
<p>这样，我们的复杂度就是排序的复杂度nlogn</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from queue import PriorityQueue</span><br><span class="line">class Solution:</span><br><span class="line">    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -&gt; int:</span><br><span class="line">        pq = PriorityQueue()</span><br><span class="line">        </span><br><span class="line">        t = []</span><br><span class="line">        for i in range(len(capital)):</span><br><span class="line">            t.append((capital[i], -profits[i]))</span><br><span class="line"></span><br><span class="line">        t.sort()</span><br><span class="line">        </span><br><span class="line">        index = 0</span><br><span class="line">        for i in range(k):</span><br><span class="line">            #print(&quot;i = %d&quot; % i)</span><br><span class="line">            </span><br><span class="line">            while index &lt; len(t):</span><br><span class="line">                #print(&quot;index = %d&quot; % index)</span><br><span class="line">                #print(t[index][0])</span><br><span class="line">                #print(w)</span><br><span class="line">                if t[index][0] &lt;= w:</span><br><span class="line">                    #print(&quot;push %d&quot; % t[index][1])</span><br><span class="line">                    pq.put(t[index][1])</span><br><span class="line">                    index += 1</span><br><span class="line">                else:</span><br><span class="line">                    break    </span><br><span class="line"></span><br><span class="line">            if pq.empty():</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            nw = pq.get()</span><br><span class="line">            if nw &lt; 0:</span><br><span class="line">                w -= nw</span><br><span class="line">                #print(&quot;nw %d&quot; % nw)</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        return w</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>1.python优先队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from queue import PriorityQueue # 导入模块</span><br><span class="line">pq = PriorityQueue()			# 建立队列</span><br><span class="line">pq.put(elem)					# push操作</span><br><span class="line">pq.got()						# pop()</span><br></pre></td></tr></table></figure>
<p>2.数组排序</p>
<p>数组名.sort()</p>
<p>注意当数组元素是多元组时，会按照第一个的大小顺序排序，然后在第一个元素相对的情况下进行第二个的比较</p>
<p>sort不提供排序方法的话，会默认按照从小到大来排序，如果想要从大到小排序，需要把reverse参数设置为True</p>
<h1 id="2021-9-6"><a href="#2021-9-6" class="headerlink" title="2021.9.6"></a>2021.9.6</h1><p><em>今日天气：小雨/雾/乌云</em></p>
<p><em>“人不可能抑制自己指甲的生长，也不可能一直压抑自己的欲望！”</em></p>
<p align="right"><em>——JOJO的奇妙冒险·疯狂钻石</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode704.二分查找</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p><strong><em>思路</em></strong></p>
<p>如题名</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        low = 0</span><br><span class="line">        high = len(nums) - 1</span><br><span class="line">        mid = (low + high) // 2</span><br><span class="line">        while low &lt; high:</span><br><span class="line">            if nums[mid] &gt;= target:</span><br><span class="line">                high = mid</span><br><span class="line">            else:</span><br><span class="line">                low = mid + 1</span><br><span class="line">            mid = (low + high) // 2</span><br><span class="line">        if nums[mid] == target:</span><br><span class="line">            return mid</span><br><span class="line">        else:</span><br><span class="line">            return -1</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>在py文件的第一行加入特定的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env ……</span><br></pre></td></tr></table></figure>
<p>这是一个解释器位置，如果想要可以直接在终端执行，就可以在文件第一行加入这样的注释，然后使用sudo chmod +x 文件名</p>
<h1 id="2021-8-29"><a href="#2021-8-29" class="headerlink" title="2021.8.29"></a>2021.8.29</h1><p><em>今日天气：小雨转阴</em></p>
<p><em>“我所追求的，不仅仅是一个结果”</em></p>
<p><em>“人一旦只追求结果，就会想方设法地抄近路”</em></p>
<p><em>“在抄近路的过程中，人又容易迷失真相，最终连做事的干劲也消耗殆尽了”</em></p>
<p align="right"><em>——JOJO的奇妙冒险·黄金之风</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode1588.所有奇数长度子数组的和</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。</p>
<p>子数组 定义为原数组中的一个连续子序列。</p>
<p>请你返回 arr 中所有奇数长度子数组的和。</p>
<p><strong><em>思路</em></strong></p>
<p>统计每个数被计算了几次即可，可以这样考虑，要形成一个奇数长子数组，假设我们需要在下标为i的数左边取a个数，右边取b个数，那么a，b要么都是奇数，要么都是偶数。</p>
<p>只要能计算出小于某个数的奇数个数和偶数个数即可</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def odd(self, x):</span><br><span class="line">        return (x + 1) // 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def even(self, x):</span><br><span class="line">        return x // 2 + 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def sumOddLengthSubarrays(self, arr: List[int]) -&gt; int:</span><br><span class="line">        ret = 0</span><br><span class="line">        for i in range(len(arr)):</span><br><span class="line">            left = i</span><br><span class="line">            right = len(arr) - i - 1</span><br><span class="line">            ret += arr[i] * (self.odd(left) * self.odd(right) + self.even(right) * self.even(left))</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>python类方法中的self参数：</p>
<p>python的self类似于C++中的this，表示当前对象，使用self.方法名/属性名就可以在方法定义中使用该对象的方法和属性</p>
<p>值得注意的是，python类方法的第一个参数一定是self</p>
<p><strong>今日知识点</strong></p>
<p><strong><em>1.弧长</em></strong></p>
<p>若已知y=f(x)，那么可以将弧切分成数小段，然后使用勾股定理计算出每段的弧长为：</p>
<p><code>(dx²+dy²)^0.5</code></p>
<p>那么有弧长微元：</p>
<p><code>dl=(dx²+dy²)^0.5=(f&#39;(x)²+1)^0.5*dx</code></p>
<p>那么在x1到x2之间的弧长，可以使用上面式子的定积分来计算</p>
<h1 id="2021-8-28"><a href="#2021-8-28" class="headerlink" title="2021.8.28"></a>2021.8.28</h1><p><em>今日天气：阴</em></p>
<p><em>我们所度过的每一个平凡的日常，也许就是接连不断发生的奇迹！</em></p>
<p align="right"><em>——日常</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode1480.一维数组的动态和</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给出一个数值，返回其前缀和数组</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def runningSum(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        ret = [0]</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            ret.append(ret[i] + nums[i])</span><br><span class="line">        del ret[0]</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>del的用法：</p>
<p>python的del不同于C的free和C++的delete。</p>
<p>由于python都是引用，而python有GC机制，所以，del语句作用在变量上，而不是数据对象上。</p>
<pre><code>if __name__==&apos;__main__&apos;:  
    a=1       # 对象 1 被 变量a引用，对象1的引用计数器为1  
    b=a       # 对象1 被变量b引用，对象1的引用计数器加1  
    c=a       #1对象1 被变量c引用，对象1的引用计数器加1  
    del a     #删除变量a，解除a对1的引用  
    del b     #删除变量b，解除b对1的引用  
    print(c)  #最终变量c仍然引用1  
</code></pre><p>del删除的是变量，而不是数据。</p>
<pre><code>if __name__==&apos;__main__&apos;:  
    li=[1,2,3,4,5]  #列表本身不包含数据1,2,3,4,5，而是包含变量：li[0] li[1] li[2] li[3] li[4]   
    first=li[0]     #拷贝列表，也不会有数据对象的复制，而是创建新的变量引用  
    del li[0]  
    print(li)      #输出[2, 3, 4, 5]  
    print(first)   #输出 1  
</code></pre><p><strong>今日知识点</strong></p>
<p><strong><em>1.t分布</em></strong></p>
<p>假设随机变量X服从标准正态分布，Y服从自由度为n的卡方分布，那么Z=X/(Y/n)^0.5服从自由度为n的t分布</p>
<p><em>t分布的性质</em></p>
<p>t分布的均值为0，概率密度左右对称</p>
<h1 id="2021-8-23"><a href="#2021-8-23" class="headerlink" title="2021.8.23"></a>2021.8.23</h1><p><em>今日天气：雨</em></p>
<p><em>人类的伟大就是勇气的伟大，人类的赞歌就是勇气的赞歌！</em></p>
<p align="right"><em>——JOJO的奇妙冒险·幻影之血</em></p>

<p><strong>今日python练习</strong></p>
<p><em>Leetcode1646.获取生成数组中的最大值</em></p>
<p><strong><em>题目描述</em></strong></p>
<p>给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：</p>
<pre><code>nums[0] = 0
nums[1] = 1
当 2 &lt;= 2 * i &lt;= n 时，nums[2 * i] = nums[i]
当 2 &lt;= 2 * i + 1 &lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]
</code></pre><p>返回生成数组 nums 中的 最大 值。</p>
<p><strong><em>数据范围</em></strong></p>
<p>0 ≤ n ≤ 100</p>
<p><strong><em>思路</em></strong></p>
<p>模拟，把100个数都算出来就好</p>
<p><strong><em>解决</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getMaximumGenerated(self, n: int) -&gt; int:</span><br><span class="line">        if n == 0:</span><br><span class="line">            return 0</span><br><span class="line">        elif n == 1:</span><br><span class="line">            return 1</span><br><span class="line">        else:</span><br><span class="line">            ret = 1</span><br><span class="line">            nums = [0, 1]</span><br><span class="line">            for i in range(2, n + 1):</span><br><span class="line">                newnum = nums[i // 2]</span><br><span class="line">                if i % 2 == 1:</span><br><span class="line">                    newnum += nums[i // 2 + 1]</span><br><span class="line">                if ret &lt; newnum:</span><br><span class="line">                    ret = newnum</span><br><span class="line">                nums.append(newnum)</span><br><span class="line">            return ret</span><br></pre></td></tr></table></figure></p>
<p><strong><em>语法复习</em></strong></p>
<p>range的用法：</p>
<p>python3的range()返回的是一个可迭代对象，常和for连用</p>
<p>函数语法为：</p>
<p>range(start，stop，step)</p>
<p>表示以step为步长，从start开始，遍历到stop之前结束</p>
<p><em>注意是stop之前，换句话说，就是不包括stop</em></p>
<p>如果步长是1，可以省略step</p>
<p>还有一种用法是range(stop)</p>
<p><em>此时表示从0开始以步长为一遍历到stop-1</em></p>
<p><strong>今日知识点</strong></p>
<p><strong><em>1.矩阵的迹</em></strong></p>
<p>在线性代数中，一个n×n矩阵A的主对角线（从左上方至右下方的对角线）上各个元素的总和被称为矩阵A的迹（或迹数），一般记作tr(A)</p>
<p><em>迹的性质</em></p>
<p>1.迹不仅仅是对角线元素的和，还是所有特征值的和</p>
<p>2.tr(mA+nB) = mtr(A) + ntr(B)</p>
<p>3.tr(AB) = tr(BA)</p>
<p><strong><em>2.三花猫</em></strong></p>
<p>猫的花色位于X染色体上，因此三花猫一般都是有两条X染色体的母猫</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/杂记/" rel="tag"># 杂记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/01/16/机器学习入门课程笔记/" rel="next" title="机器学习入门课程笔记">
                <i class="fa fa-chevron-left"></i> 机器学习入门课程笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/01/16/Unity-2D基础/" rel="prev" title="Unity 2D基础">
                Unity 2D基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jameci</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#2022-1-24"><span class="nav-number">1.</span> <span class="nav-text">2022.1.24</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2022-1-23"><span class="nav-number">2.</span> <span class="nav-text">2022.1.23</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2022-1-22"><span class="nav-number">3.</span> <span class="nav-text">2022.1.22</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-1-21"><span class="nav-number">4.</span> <span class="nav-text">2021.1.21</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2022-1-20"><span class="nav-number">5.</span> <span class="nav-text">2022.1.20</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2022-1-19"><span class="nav-number">6.</span> <span class="nav-text">2022.1.19</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-11-3"><span class="nav-number">7.</span> <span class="nav-text">2021.11.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-11-1"><span class="nav-number">8.</span> <span class="nav-text">2021.11.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-31"><span class="nav-number">9.</span> <span class="nav-text">2021.10.31</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-30"><span class="nav-number">10.</span> <span class="nav-text">2021.10.30</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-28"><span class="nav-number">11.</span> <span class="nav-text">2021.10.28</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-27"><span class="nav-number">12.</span> <span class="nav-text">2021.10.27</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-26"><span class="nav-number">13.</span> <span class="nav-text">2021.10.26</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-25"><span class="nav-number">14.</span> <span class="nav-text">2021.10.25</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-24"><span class="nav-number">15.</span> <span class="nav-text">2021.10.24</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-23"><span class="nav-number">16.</span> <span class="nav-text">2021.10.23</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-21"><span class="nav-number">17.</span> <span class="nav-text">2021.10.21</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-20"><span class="nav-number">18.</span> <span class="nav-text">2021.10.20</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-18"><span class="nav-number">19.</span> <span class="nav-text">2021.10.18</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-17"><span class="nav-number">20.</span> <span class="nav-text">2021.10.17</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-16"><span class="nav-number">21.</span> <span class="nav-text">2021.10.16</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-15"><span class="nav-number">22.</span> <span class="nav-text">2021.10.15</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-14"><span class="nav-number">23.</span> <span class="nav-text">2021.10.14</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-13"><span class="nav-number">24.</span> <span class="nav-text">2021.10.13</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-12"><span class="nav-number">25.</span> <span class="nav-text">2021.10.12</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-11"><span class="nav-number">26.</span> <span class="nav-text">2021.10.11</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-10"><span class="nav-number">27.</span> <span class="nav-text">2021.10.10</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-8"><span class="nav-number">28.</span> <span class="nav-text">2021.10.8</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-7"><span class="nav-number">29.</span> <span class="nav-text">2021.10.7</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-6"><span class="nav-number">30.</span> <span class="nav-text">2021.10.6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-4"><span class="nav-number">31.</span> <span class="nav-text">2021.10.4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-3"><span class="nav-number">32.</span> <span class="nav-text">2021.10.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-2"><span class="nav-number">33.</span> <span class="nav-text">2021.10.2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-10-1"><span class="nav-number">34.</span> <span class="nav-text">2021.10.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-30"><span class="nav-number">35.</span> <span class="nav-text">2021.9.30</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-27"><span class="nav-number">36.</span> <span class="nav-text">2021.9.27</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-24"><span class="nav-number">37.</span> <span class="nav-text">2021.9.24</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-23"><span class="nav-number">38.</span> <span class="nav-text">2021.9.23</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-22"><span class="nav-number">39.</span> <span class="nav-text">2021.9.22</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-21"><span class="nav-number">40.</span> <span class="nav-text">2021.9.21</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-20"><span class="nav-number">41.</span> <span class="nav-text">2021.9.20</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-19"><span class="nav-number">42.</span> <span class="nav-text">2021.9.19</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-18"><span class="nav-number">43.</span> <span class="nav-text">2021.9.18</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-17"><span class="nav-number">44.</span> <span class="nav-text">2021.9.17</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-16"><span class="nav-number">45.</span> <span class="nav-text">2021.9.16</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-15"><span class="nav-number">46.</span> <span class="nav-text">2021.9.15</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-14"><span class="nav-number">47.</span> <span class="nav-text">2021.9.14</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-13"><span class="nav-number">48.</span> <span class="nav-text">2021.9.13</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-12"><span class="nav-number">49.</span> <span class="nav-text">2021.9.12</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-11"><span class="nav-number">50.</span> <span class="nav-text">2021.9.11</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-10"><span class="nav-number">51.</span> <span class="nav-text">2021.9.10</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-9"><span class="nav-number">52.</span> <span class="nav-text">2021.9.9</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-8"><span class="nav-number">53.</span> <span class="nav-text">2021.9.8</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-9-6"><span class="nav-number">54.</span> <span class="nav-text">2021.9.6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-8-29"><span class="nav-number">55.</span> <span class="nav-text">2021.8.29</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-8-28"><span class="nav-number">56.</span> <span class="nav-text">2021.8.28</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021-8-23"><span class="nav-number">57.</span> <span class="nav-text">2021.8.23</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jameci</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
